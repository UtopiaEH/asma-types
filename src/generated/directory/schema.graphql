schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

input InsertUserData {
  brukerBrukerNavn: String
  brukerRegion: Int
  customer_id: uuid
  email: String!
  name: String!
  password: String!
  phone: String!
  role: String
  token: String
}

type InsertUserOrWarnIfExistsOutput {
  affected_rows: Int!
  id: uuid!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

type ReturnAffectedItemId {
  id: uuid!
}

type ReturnAffectedRows {
  affected_rows: Int
}

type SigninOutput {
  message: String
  token: String!
}

type SinginOutputWithRefreshToken {
  message: String
  refresh_token: String!
  token: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type UpdateUserOutput {
  affected_rows: Int!
}

"""
columns and relationships of "admins"
"""
type admins {
  """
  fetch data from the table: "admins_auth_logs"
  """
  admins_auth_logs(
    """distinct select on columns"""
    distinct_on: [admins_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_auth_logs_order_by!]

    """filter the rows returned"""
    where: admins_auth_logs_bool_exp
  ): [admins_auth_logs!]!

  """An aggregate relationship"""
  admins_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [admins_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_auth_logs_order_by!]

    """filter the rows returned"""
    where: admins_auth_logs_bool_exp
  ): admins_auth_logs_aggregate!
  created_at: timestamptz
  email: bpchar!
  id: uuid!
  name: bpchar!
  password: bpchar!
  phone: String
  updated_at: timestamptz
}

"""
aggregated selection of "admins"
"""
type admins_aggregate {
  aggregate: admins_aggregate_fields
  nodes: [admins!]!
}

"""
aggregate fields of "admins"
"""
type admins_aggregate_fields {
  count(columns: [admins_select_column!], distinct: Boolean): Int!
  max: admins_max_fields
  min: admins_min_fields
}

"""
columns and relationships of "admins_auth_logs"
"""
type admins_auth_logs {
  """An object relationship"""
  admin: admins!
  admin_id: uuid!
  authenticated_at: timestamptz
  id: Int!
}

"""
aggregated selection of "admins_auth_logs"
"""
type admins_auth_logs_aggregate {
  aggregate: admins_auth_logs_aggregate_fields
  nodes: [admins_auth_logs!]!
}

"""
aggregate fields of "admins_auth_logs"
"""
type admins_auth_logs_aggregate_fields {
  avg: admins_auth_logs_avg_fields
  count(columns: [admins_auth_logs_select_column!], distinct: Boolean): Int!
  max: admins_auth_logs_max_fields
  min: admins_auth_logs_min_fields
  stddev: admins_auth_logs_stddev_fields
  stddev_pop: admins_auth_logs_stddev_pop_fields
  stddev_samp: admins_auth_logs_stddev_samp_fields
  sum: admins_auth_logs_sum_fields
  var_pop: admins_auth_logs_var_pop_fields
  var_samp: admins_auth_logs_var_samp_fields
  variance: admins_auth_logs_variance_fields
}

"""
order by aggregate values of table "admins_auth_logs"
"""
input admins_auth_logs_aggregate_order_by {
  avg: admins_auth_logs_avg_order_by
  count: order_by
  max: admins_auth_logs_max_order_by
  min: admins_auth_logs_min_order_by
  stddev: admins_auth_logs_stddev_order_by
  stddev_pop: admins_auth_logs_stddev_pop_order_by
  stddev_samp: admins_auth_logs_stddev_samp_order_by
  sum: admins_auth_logs_sum_order_by
  var_pop: admins_auth_logs_var_pop_order_by
  var_samp: admins_auth_logs_var_samp_order_by
  variance: admins_auth_logs_variance_order_by
}

"""
input type for inserting array relation for remote table "admins_auth_logs"
"""
input admins_auth_logs_arr_rel_insert_input {
  data: [admins_auth_logs_insert_input!]!

  """on conflict condition"""
  on_conflict: admins_auth_logs_on_conflict
}

"""aggregate avg on columns"""
type admins_auth_logs_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "admins_auth_logs". All fields are combined with a logical 'AND'.
"""
input admins_auth_logs_bool_exp {
  _and: [admins_auth_logs_bool_exp!]
  _not: admins_auth_logs_bool_exp
  _or: [admins_auth_logs_bool_exp!]
  admin: admins_bool_exp
  admin_id: uuid_comparison_exp
  authenticated_at: timestamptz_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "admins_auth_logs"
"""
enum admins_auth_logs_constraint {
  """unique or primary key constraint"""
  admins_auth_logs_pkey
}

"""
input type for incrementing numeric columns in table "admins_auth_logs"
"""
input admins_auth_logs_inc_input {
  id: Int
}

"""
input type for inserting data into table "admins_auth_logs"
"""
input admins_auth_logs_insert_input {
  admin: admins_obj_rel_insert_input
  admin_id: uuid
  authenticated_at: timestamptz
  id: Int
}

"""aggregate max on columns"""
type admins_auth_logs_max_fields {
  admin_id: uuid
  authenticated_at: timestamptz
  id: Int
}

"""
order by max() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_max_order_by {
  admin_id: order_by
  authenticated_at: order_by
  id: order_by
}

"""aggregate min on columns"""
type admins_auth_logs_min_fields {
  admin_id: uuid
  authenticated_at: timestamptz
  id: Int
}

"""
order by min() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_min_order_by {
  admin_id: order_by
  authenticated_at: order_by
  id: order_by
}

"""
response of any mutation on the table "admins_auth_logs"
"""
type admins_auth_logs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [admins_auth_logs!]!
}

"""
on conflict condition type for table "admins_auth_logs"
"""
input admins_auth_logs_on_conflict {
  constraint: admins_auth_logs_constraint!
  update_columns: [admins_auth_logs_update_column!]! = []
  where: admins_auth_logs_bool_exp
}

"""Ordering options when selecting data from "admins_auth_logs"."""
input admins_auth_logs_order_by {
  admin: admins_order_by
  admin_id: order_by
  authenticated_at: order_by
  id: order_by
}

"""primary key columns input for table: admins_auth_logs"""
input admins_auth_logs_pk_columns_input {
  id: Int!
}

"""
select columns of table "admins_auth_logs"
"""
enum admins_auth_logs_select_column {
  """column name"""
  admin_id

  """column name"""
  authenticated_at

  """column name"""
  id
}

"""
input type for updating data in table "admins_auth_logs"
"""
input admins_auth_logs_set_input {
  admin_id: uuid
  authenticated_at: timestamptz
  id: Int
}

"""aggregate stddev on columns"""
type admins_auth_logs_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type admins_auth_logs_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type admins_auth_logs_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type admins_auth_logs_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_sum_order_by {
  id: order_by
}

"""
update columns of table "admins_auth_logs"
"""
enum admins_auth_logs_update_column {
  """column name"""
  admin_id

  """column name"""
  authenticated_at

  """column name"""
  id
}

"""aggregate var_pop on columns"""
type admins_auth_logs_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type admins_auth_logs_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type admins_auth_logs_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "admins_auth_logs"
"""
input admins_auth_logs_variance_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "admins". All fields are combined with a logical 'AND'.
"""
input admins_bool_exp {
  _and: [admins_bool_exp!]
  _not: admins_bool_exp
  _or: [admins_bool_exp!]
  admins_auth_logs: admins_auth_logs_bool_exp
  created_at: timestamptz_comparison_exp
  email: bpchar_comparison_exp
  id: uuid_comparison_exp
  name: bpchar_comparison_exp
  password: bpchar_comparison_exp
  phone: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "admins"
"""
enum admins_constraint {
  """unique or primary key constraint"""
  admins_phone_key

  """unique or primary key constraint"""
  admins_pkey
}

"""
input type for inserting data into table "admins"
"""
input admins_insert_input {
  admins_auth_logs: admins_auth_logs_arr_rel_insert_input
  created_at: timestamptz
  email: bpchar
  id: uuid
  name: bpchar
  password: bpchar
  phone: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type admins_max_fields {
  created_at: timestamptz
  email: bpchar
  id: uuid
  name: bpchar
  password: bpchar
  phone: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type admins_min_fields {
  created_at: timestamptz
  email: bpchar
  id: uuid
  name: bpchar
  password: bpchar
  phone: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "admins"
"""
type admins_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [admins!]!
}

"""
input type for inserting object relation for remote table "admins"
"""
input admins_obj_rel_insert_input {
  data: admins_insert_input!

  """on conflict condition"""
  on_conflict: admins_on_conflict
}

"""
on conflict condition type for table "admins"
"""
input admins_on_conflict {
  constraint: admins_constraint!
  update_columns: [admins_update_column!]! = []
  where: admins_bool_exp
}

"""Ordering options when selecting data from "admins"."""
input admins_order_by {
  admins_auth_logs_aggregate: admins_auth_logs_aggregate_order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  password: order_by
  phone: order_by
  updated_at: order_by
}

"""primary key columns input for table: admins"""
input admins_pk_columns_input {
  id: uuid!
}

"""
select columns of table "admins"
"""
enum admins_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  password

  """column name"""
  phone

  """column name"""
  updated_at
}

"""
input type for updating data in table "admins"
"""
input admins_set_input {
  created_at: timestamptz
  email: bpchar
  id: uuid
  name: bpchar
  password: bpchar
  phone: String
  updated_at: timestamptz
}

"""
update columns of table "admins"
"""
enum admins_update_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  password

  """column name"""
  phone

  """column name"""
  updated_at
}

"""
columns and relationships of "auth_methods"
"""
type auth_methods {
  comment: String
  name: String!

  """An array relationship"""
  users_auth_logs(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): [users_auth_logs!]!

  """An aggregate relationship"""
  users_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): users_auth_logs_aggregate!
}

"""
aggregated selection of "auth_methods"
"""
type auth_methods_aggregate {
  aggregate: auth_methods_aggregate_fields
  nodes: [auth_methods!]!
}

"""
aggregate fields of "auth_methods"
"""
type auth_methods_aggregate_fields {
  count(columns: [auth_methods_select_column!], distinct: Boolean): Int!
  max: auth_methods_max_fields
  min: auth_methods_min_fields
}

"""
Boolean expression to filter rows from the table "auth_methods". All fields are combined with a logical 'AND'.
"""
input auth_methods_bool_exp {
  _and: [auth_methods_bool_exp!]
  _not: auth_methods_bool_exp
  _or: [auth_methods_bool_exp!]
  comment: String_comparison_exp
  name: String_comparison_exp
  users_auth_logs: users_auth_logs_bool_exp
}

"""
unique or primary key constraints on table "auth_methods"
"""
enum auth_methods_constraint {
  """unique or primary key constraint"""
  auth_methods_pkey
}

enum auth_methods_enum {
  BASIC
  CONNECTOR

  """norvegian bank id"""
  NBID

  """norvegian bank id"""
  SMS
}

"""
Boolean expression to compare columns of type "auth_methods_enum". All fields are combined with logical 'AND'.
"""
input auth_methods_enum_comparison_exp {
  _eq: auth_methods_enum
  _in: [auth_methods_enum!]
  _is_null: Boolean
  _neq: auth_methods_enum
  _nin: [auth_methods_enum!]
}

"""
input type for inserting data into table "auth_methods"
"""
input auth_methods_insert_input {
  comment: String
  name: String
  users_auth_logs: users_auth_logs_arr_rel_insert_input
}

"""aggregate max on columns"""
type auth_methods_max_fields {
  comment: String
  name: String
}

"""aggregate min on columns"""
type auth_methods_min_fields {
  comment: String
  name: String
}

"""
response of any mutation on the table "auth_methods"
"""
type auth_methods_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auth_methods!]!
}

"""
input type for inserting object relation for remote table "auth_methods"
"""
input auth_methods_obj_rel_insert_input {
  data: auth_methods_insert_input!

  """on conflict condition"""
  on_conflict: auth_methods_on_conflict
}

"""
on conflict condition type for table "auth_methods"
"""
input auth_methods_on_conflict {
  constraint: auth_methods_constraint!
  update_columns: [auth_methods_update_column!]! = []
  where: auth_methods_bool_exp
}

"""Ordering options when selecting data from "auth_methods"."""
input auth_methods_order_by {
  comment: order_by
  name: order_by
  users_auth_logs_aggregate: users_auth_logs_aggregate_order_by
}

"""primary key columns input for table: auth_methods"""
input auth_methods_pk_columns_input {
  name: String!
}

"""
select columns of table "auth_methods"
"""
enum auth_methods_select_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
input type for updating data in table "auth_methods"
"""
input auth_methods_set_input {
  comment: String
  name: String
}

"""
update columns of table "auth_methods"
"""
enum auth_methods_update_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
columns and relationships of "blacklist_refresh_token"
"""
type blacklist_refresh_token {
  sig: String!
  user_id: uuid!
  valid_till: timestamptz!
}

"""
aggregated selection of "blacklist_refresh_token"
"""
type blacklist_refresh_token_aggregate {
  aggregate: blacklist_refresh_token_aggregate_fields
  nodes: [blacklist_refresh_token!]!
}

"""
aggregate fields of "blacklist_refresh_token"
"""
type blacklist_refresh_token_aggregate_fields {
  count(columns: [blacklist_refresh_token_select_column!], distinct: Boolean): Int!
  max: blacklist_refresh_token_max_fields
  min: blacklist_refresh_token_min_fields
}

"""
Boolean expression to filter rows from the table "blacklist_refresh_token". All fields are combined with a logical 'AND'.
"""
input blacklist_refresh_token_bool_exp {
  _and: [blacklist_refresh_token_bool_exp!]
  _not: blacklist_refresh_token_bool_exp
  _or: [blacklist_refresh_token_bool_exp!]
  sig: String_comparison_exp
  user_id: uuid_comparison_exp
  valid_till: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "blacklist_refresh_token"
"""
enum blacklist_refresh_token_constraint {
  """unique or primary key constraint"""
  blacklist_refresh_token_user_id_key

  """unique or primary key constraint"""
  refresh_tokens_pkey
}

"""
input type for inserting data into table "blacklist_refresh_token"
"""
input blacklist_refresh_token_insert_input {
  sig: String
  user_id: uuid
  valid_till: timestamptz
}

"""aggregate max on columns"""
type blacklist_refresh_token_max_fields {
  sig: String
  user_id: uuid
  valid_till: timestamptz
}

"""aggregate min on columns"""
type blacklist_refresh_token_min_fields {
  sig: String
  user_id: uuid
  valid_till: timestamptz
}

"""
response of any mutation on the table "blacklist_refresh_token"
"""
type blacklist_refresh_token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [blacklist_refresh_token!]!
}

"""
input type for inserting object relation for remote table "blacklist_refresh_token"
"""
input blacklist_refresh_token_obj_rel_insert_input {
  data: blacklist_refresh_token_insert_input!

  """on conflict condition"""
  on_conflict: blacklist_refresh_token_on_conflict
}

"""
on conflict condition type for table "blacklist_refresh_token"
"""
input blacklist_refresh_token_on_conflict {
  constraint: blacklist_refresh_token_constraint!
  update_columns: [blacklist_refresh_token_update_column!]! = []
  where: blacklist_refresh_token_bool_exp
}

"""Ordering options when selecting data from "blacklist_refresh_token"."""
input blacklist_refresh_token_order_by {
  sig: order_by
  user_id: order_by
  valid_till: order_by
}

"""primary key columns input for table: blacklist_refresh_token"""
input blacklist_refresh_token_pk_columns_input {
  sig: String!
}

"""
select columns of table "blacklist_refresh_token"
"""
enum blacklist_refresh_token_select_column {
  """column name"""
  sig

  """column name"""
  user_id

  """column name"""
  valid_till
}

"""
input type for updating data in table "blacklist_refresh_token"
"""
input blacklist_refresh_token_set_input {
  sig: String
  user_id: uuid
  valid_till: timestamptz
}

"""
update columns of table "blacklist_refresh_token"
"""
enum blacklist_refresh_token_update_column {
  """column name"""
  sig

  """column name"""
  user_id

  """column name"""
  valid_till
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "connectors"
"""
type connectors {
  comment: String!

  """An array relationship"""
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """An aggregate relationship"""
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!
  name: String!
}

"""
aggregated selection of "connectors"
"""
type connectors_aggregate {
  aggregate: connectors_aggregate_fields
  nodes: [connectors!]!
}

"""
aggregate fields of "connectors"
"""
type connectors_aggregate_fields {
  count(columns: [connectors_select_column!], distinct: Boolean): Int!
  max: connectors_max_fields
  min: connectors_min_fields
}

"""
Boolean expression to filter rows from the table "connectors". All fields are combined with a logical 'AND'.
"""
input connectors_bool_exp {
  _and: [connectors_bool_exp!]
  _not: connectors_bool_exp
  _or: [connectors_bool_exp!]
  comment: String_comparison_exp
  customers: customers_bool_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "connectors"
"""
enum connectors_constraint {
  """unique or primary key constraint"""
  customer_connectors_pkey
}

enum connectors_enum {
  """comment"""
  ADCURIS

  """comment"""
  ADOPUS
}

"""
Boolean expression to compare columns of type "connectors_enum". All fields are combined with logical 'AND'.
"""
input connectors_enum_comparison_exp {
  _eq: connectors_enum
  _in: [connectors_enum!]
  _is_null: Boolean
  _neq: connectors_enum
  _nin: [connectors_enum!]
}

"""
input type for inserting data into table "connectors"
"""
input connectors_insert_input {
  comment: String
  customers: customers_arr_rel_insert_input
  name: String
}

"""aggregate max on columns"""
type connectors_max_fields {
  comment: String
  name: String
}

"""aggregate min on columns"""
type connectors_min_fields {
  comment: String
  name: String
}

"""
response of any mutation on the table "connectors"
"""
type connectors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [connectors!]!
}

"""
input type for inserting object relation for remote table "connectors"
"""
input connectors_obj_rel_insert_input {
  data: connectors_insert_input!

  """on conflict condition"""
  on_conflict: connectors_on_conflict
}

"""
on conflict condition type for table "connectors"
"""
input connectors_on_conflict {
  constraint: connectors_constraint!
  update_columns: [connectors_update_column!]! = []
  where: connectors_bool_exp
}

"""Ordering options when selecting data from "connectors"."""
input connectors_order_by {
  comment: order_by
  customers_aggregate: customers_aggregate_order_by
  name: order_by
}

"""primary key columns input for table: connectors"""
input connectors_pk_columns_input {
  name: String!
}

"""
select columns of table "connectors"
"""
enum connectors_select_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
input type for updating data in table "connectors"
"""
input connectors_set_input {
  comment: String
  name: String
}

"""
update columns of table "connectors"
"""
enum connectors_update_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
columns and relationships of "customer_user"
"""
type customer_user {
  brukerBrukerNavn: String

  """An object relationship"""
  customer: customers!
  customer_id: uuid!
  region: Int

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "customer_user"
"""
type customer_user_aggregate {
  aggregate: customer_user_aggregate_fields
  nodes: [customer_user!]!
}

"""
aggregate fields of "customer_user"
"""
type customer_user_aggregate_fields {
  avg: customer_user_avg_fields
  count(columns: [customer_user_select_column!], distinct: Boolean): Int!
  max: customer_user_max_fields
  min: customer_user_min_fields
  stddev: customer_user_stddev_fields
  stddev_pop: customer_user_stddev_pop_fields
  stddev_samp: customer_user_stddev_samp_fields
  sum: customer_user_sum_fields
  var_pop: customer_user_var_pop_fields
  var_samp: customer_user_var_samp_fields
  variance: customer_user_variance_fields
}

"""
order by aggregate values of table "customer_user"
"""
input customer_user_aggregate_order_by {
  avg: customer_user_avg_order_by
  count: order_by
  max: customer_user_max_order_by
  min: customer_user_min_order_by
  stddev: customer_user_stddev_order_by
  stddev_pop: customer_user_stddev_pop_order_by
  stddev_samp: customer_user_stddev_samp_order_by
  sum: customer_user_sum_order_by
  var_pop: customer_user_var_pop_order_by
  var_samp: customer_user_var_samp_order_by
  variance: customer_user_variance_order_by
}

"""
input type for inserting array relation for remote table "customer_user"
"""
input customer_user_arr_rel_insert_input {
  data: [customer_user_insert_input!]!

  """on conflict condition"""
  on_conflict: customer_user_on_conflict
}

"""aggregate avg on columns"""
type customer_user_avg_fields {
  region: Float
}

"""
order by avg() on columns of table "customer_user"
"""
input customer_user_avg_order_by {
  region: order_by
}

"""
Boolean expression to filter rows from the table "customer_user". All fields are combined with a logical 'AND'.
"""
input customer_user_bool_exp {
  _and: [customer_user_bool_exp!]
  _not: customer_user_bool_exp
  _or: [customer_user_bool_exp!]
  brukerBrukerNavn: String_comparison_exp
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  region: Int_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "customer_user"
"""
enum customer_user_constraint {
  """unique or primary key constraint"""
  customer_user_pkey
}

"""
input type for incrementing numeric columns in table "customer_user"
"""
input customer_user_inc_input {
  region: Int
}

"""
input type for inserting data into table "customer_user"
"""
input customer_user_insert_input {
  brukerBrukerNavn: String
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  region: Int
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type customer_user_max_fields {
  brukerBrukerNavn: String
  customer_id: uuid
  region: Int
  user_id: uuid
}

"""
order by max() on columns of table "customer_user"
"""
input customer_user_max_order_by {
  brukerBrukerNavn: order_by
  customer_id: order_by
  region: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type customer_user_min_fields {
  brukerBrukerNavn: String
  customer_id: uuid
  region: Int
  user_id: uuid
}

"""
order by min() on columns of table "customer_user"
"""
input customer_user_min_order_by {
  brukerBrukerNavn: order_by
  customer_id: order_by
  region: order_by
  user_id: order_by
}

"""
response of any mutation on the table "customer_user"
"""
type customer_user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_user!]!
}

"""
on conflict condition type for table "customer_user"
"""
input customer_user_on_conflict {
  constraint: customer_user_constraint!
  update_columns: [customer_user_update_column!]! = []
  where: customer_user_bool_exp
}

"""Ordering options when selecting data from "customer_user"."""
input customer_user_order_by {
  brukerBrukerNavn: order_by
  customer: customers_order_by
  customer_id: order_by
  region: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: customer_user"""
input customer_user_pk_columns_input {
  customer_id: uuid!
  user_id: uuid!
}

"""
select columns of table "customer_user"
"""
enum customer_user_select_column {
  """column name"""
  brukerBrukerNavn

  """column name"""
  customer_id

  """column name"""
  region

  """column name"""
  user_id
}

"""
columns and relationships of "customer_user_service"
"""
type customer_user_service {
  """An object relationship"""
  customer: customers!
  customer_id: uuid!
  service: services_enum!

  """An object relationship"""
  serviceByService: services!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "customer_user_service"
"""
type customer_user_service_aggregate {
  aggregate: customer_user_service_aggregate_fields
  nodes: [customer_user_service!]!
}

"""
aggregate fields of "customer_user_service"
"""
type customer_user_service_aggregate_fields {
  count(columns: [customer_user_service_select_column!], distinct: Boolean): Int!
  max: customer_user_service_max_fields
  min: customer_user_service_min_fields
}

"""
order by aggregate values of table "customer_user_service"
"""
input customer_user_service_aggregate_order_by {
  count: order_by
  max: customer_user_service_max_order_by
  min: customer_user_service_min_order_by
}

"""
input type for inserting array relation for remote table "customer_user_service"
"""
input customer_user_service_arr_rel_insert_input {
  data: [customer_user_service_insert_input!]!

  """on conflict condition"""
  on_conflict: customer_user_service_on_conflict
}

"""
Boolean expression to filter rows from the table "customer_user_service". All fields are combined with a logical 'AND'.
"""
input customer_user_service_bool_exp {
  _and: [customer_user_service_bool_exp!]
  _not: customer_user_service_bool_exp
  _or: [customer_user_service_bool_exp!]
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  service: services_enum_comparison_exp
  serviceByService: services_bool_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "customer_user_service"
"""
enum customer_user_service_constraint {
  """unique or primary key constraint"""
  customer_user_service_pkey
}

"""
input type for inserting data into table "customer_user_service"
"""
input customer_user_service_insert_input {
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  service: services_enum
  serviceByService: services_obj_rel_insert_input
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type customer_user_service_max_fields {
  customer_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "customer_user_service"
"""
input customer_user_service_max_order_by {
  customer_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type customer_user_service_min_fields {
  customer_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "customer_user_service"
"""
input customer_user_service_min_order_by {
  customer_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "customer_user_service"
"""
type customer_user_service_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_user_service!]!
}

"""
on conflict condition type for table "customer_user_service"
"""
input customer_user_service_on_conflict {
  constraint: customer_user_service_constraint!
  update_columns: [customer_user_service_update_column!]! = []
  where: customer_user_service_bool_exp
}

"""Ordering options when selecting data from "customer_user_service"."""
input customer_user_service_order_by {
  customer: customers_order_by
  customer_id: order_by
  service: order_by
  serviceByService: services_order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: customer_user_service"""
input customer_user_service_pk_columns_input {
  customer_id: uuid!
  service: services_enum!
  user_id: uuid!
}

"""
select columns of table "customer_user_service"
"""
enum customer_user_service_select_column {
  """column name"""
  customer_id

  """column name"""
  service

  """column name"""
  user_id
}

"""
input type for updating data in table "customer_user_service"
"""
input customer_user_service_set_input {
  customer_id: uuid
  service: services_enum
  user_id: uuid
}

"""
update columns of table "customer_user_service"
"""
enum customer_user_service_update_column {
  """column name"""
  customer_id

  """column name"""
  service

  """column name"""
  user_id
}

"""
input type for updating data in table "customer_user"
"""
input customer_user_set_input {
  brukerBrukerNavn: String
  customer_id: uuid
  region: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type customer_user_stddev_fields {
  region: Float
}

"""
order by stddev() on columns of table "customer_user"
"""
input customer_user_stddev_order_by {
  region: order_by
}

"""aggregate stddev_pop on columns"""
type customer_user_stddev_pop_fields {
  region: Float
}

"""
order by stddev_pop() on columns of table "customer_user"
"""
input customer_user_stddev_pop_order_by {
  region: order_by
}

"""aggregate stddev_samp on columns"""
type customer_user_stddev_samp_fields {
  region: Float
}

"""
order by stddev_samp() on columns of table "customer_user"
"""
input customer_user_stddev_samp_order_by {
  region: order_by
}

"""
columns and relationships of "customer_user_sub_service"
"""
type customer_user_sub_service {
  """An object relationship"""
  customer: customers!
  customer_id: uuid!
  service: services_enum!

  """An object relationship"""
  serviceByService: services!

  """An object relationship"""
  subServiceByServiceSubService: sub_services

  """An object relationship"""
  subServiceBySubService: sub_services
  sub_service: String!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "customer_user_sub_service"
"""
type customer_user_sub_service_aggregate {
  aggregate: customer_user_sub_service_aggregate_fields
  nodes: [customer_user_sub_service!]!
}

"""
aggregate fields of "customer_user_sub_service"
"""
type customer_user_sub_service_aggregate_fields {
  count(columns: [customer_user_sub_service_select_column!], distinct: Boolean): Int!
  max: customer_user_sub_service_max_fields
  min: customer_user_sub_service_min_fields
}

"""
order by aggregate values of table "customer_user_sub_service"
"""
input customer_user_sub_service_aggregate_order_by {
  count: order_by
  max: customer_user_sub_service_max_order_by
  min: customer_user_sub_service_min_order_by
}

"""
input type for inserting array relation for remote table "customer_user_sub_service"
"""
input customer_user_sub_service_arr_rel_insert_input {
  data: [customer_user_sub_service_insert_input!]!

  """on conflict condition"""
  on_conflict: customer_user_sub_service_on_conflict
}

"""
Boolean expression to filter rows from the table "customer_user_sub_service". All fields are combined with a logical 'AND'.
"""
input customer_user_sub_service_bool_exp {
  _and: [customer_user_sub_service_bool_exp!]
  _not: customer_user_sub_service_bool_exp
  _or: [customer_user_sub_service_bool_exp!]
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  service: services_enum_comparison_exp
  serviceByService: services_bool_exp
  subServiceByServiceSubService: sub_services_bool_exp
  subServiceBySubService: sub_services_bool_exp
  sub_service: String_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "customer_user_sub_service"
"""
enum customer_user_sub_service_constraint {
  """unique or primary key constraint"""
  customer_user_sub_service_pkey
}

"""
input type for inserting data into table "customer_user_sub_service"
"""
input customer_user_sub_service_insert_input {
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  service: services_enum
  serviceByService: services_obj_rel_insert_input
  subServiceByServiceSubService: sub_services_obj_rel_insert_input
  subServiceBySubService: sub_services_obj_rel_insert_input
  sub_service: String
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type customer_user_sub_service_max_fields {
  customer_id: uuid
  sub_service: String
  user_id: uuid
}

"""
order by max() on columns of table "customer_user_sub_service"
"""
input customer_user_sub_service_max_order_by {
  customer_id: order_by
  sub_service: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type customer_user_sub_service_min_fields {
  customer_id: uuid
  sub_service: String
  user_id: uuid
}

"""
order by min() on columns of table "customer_user_sub_service"
"""
input customer_user_sub_service_min_order_by {
  customer_id: order_by
  sub_service: order_by
  user_id: order_by
}

"""
response of any mutation on the table "customer_user_sub_service"
"""
type customer_user_sub_service_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customer_user_sub_service!]!
}

"""
on conflict condition type for table "customer_user_sub_service"
"""
input customer_user_sub_service_on_conflict {
  constraint: customer_user_sub_service_constraint!
  update_columns: [customer_user_sub_service_update_column!]! = []
  where: customer_user_sub_service_bool_exp
}

"""Ordering options when selecting data from "customer_user_sub_service"."""
input customer_user_sub_service_order_by {
  customer: customers_order_by
  customer_id: order_by
  service: order_by
  serviceByService: services_order_by
  subServiceByServiceSubService: sub_services_order_by
  subServiceBySubService: sub_services_order_by
  sub_service: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: customer_user_sub_service"""
input customer_user_sub_service_pk_columns_input {
  customer_id: uuid!
  service: services_enum!
  sub_service: String!
  user_id: uuid!
}

"""
select columns of table "customer_user_sub_service"
"""
enum customer_user_sub_service_select_column {
  """column name"""
  customer_id

  """column name"""
  service

  """column name"""
  sub_service

  """column name"""
  user_id
}

"""
input type for updating data in table "customer_user_sub_service"
"""
input customer_user_sub_service_set_input {
  customer_id: uuid
  service: services_enum
  sub_service: String
  user_id: uuid
}

"""
update columns of table "customer_user_sub_service"
"""
enum customer_user_sub_service_update_column {
  """column name"""
  customer_id

  """column name"""
  service

  """column name"""
  sub_service

  """column name"""
  user_id
}

"""aggregate sum on columns"""
type customer_user_sum_fields {
  region: Int
}

"""
order by sum() on columns of table "customer_user"
"""
input customer_user_sum_order_by {
  region: order_by
}

"""
update columns of table "customer_user"
"""
enum customer_user_update_column {
  """column name"""
  brukerBrukerNavn

  """column name"""
  customer_id

  """column name"""
  region

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type customer_user_var_pop_fields {
  region: Float
}

"""
order by var_pop() on columns of table "customer_user"
"""
input customer_user_var_pop_order_by {
  region: order_by
}

"""aggregate var_samp on columns"""
type customer_user_var_samp_fields {
  region: Float
}

"""
order by var_samp() on columns of table "customer_user"
"""
input customer_user_var_samp_order_by {
  region: order_by
}

"""aggregate variance on columns"""
type customer_user_variance_fields {
  region: Float
}

"""
order by variance() on columns of table "customer_user"
"""
input customer_user_variance_order_by {
  region: order_by
}

"""
columns and relationships of "customers"
"""
type customers {
  conn_string: String!
  connector: connectors_enum!

  """An object relationship"""
  connectorByConnector: connectors!
  created_at: timestamptz

  """An array relationship"""
  customer_srv_urls(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): [srv_urls!]!

  """An aggregate relationship"""
  customer_srv_urls_aggregate(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): srv_urls_aggregate!

  """An array relationship"""
  customer_user_services(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): [customer_user_service!]!

  """An aggregate relationship"""
  customer_user_services_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): customer_user_service_aggregate!

  """An array relationship"""
  customer_user_sub_services(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): [customer_user_sub_service!]!

  """An aggregate relationship"""
  customer_user_sub_services_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): customer_user_sub_service_aggregate!

  """An array relationship"""
  customer_users(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): [customer_user!]!

  """An aggregate relationship"""
  customer_users_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): customer_user_aggregate!

  """An object relationship"""
  customers_contact: customers_contact
  deleted_at: timestamptz

  """An array relationship"""
  features(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): [features!]!

  """An aggregate relationship"""
  features_aggregate(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): features_aggregate!
  id: uuid!
  name: String!
  org_nr: String

  """An object relationship"""
  partner: partners
  partner_id: uuid
  refresh_token_validity: Int!
  status: status_enum!

  """An object relationship"""
  statusByStatus: status!
  updated_at: timestamptz

  """An array relationship"""
  users_auth_logs(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): [users_auth_logs!]!

  """An aggregate relationship"""
  users_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): users_auth_logs_aggregate!
}

"""
aggregated selection of "customers"
"""
type customers_aggregate {
  aggregate: customers_aggregate_fields
  nodes: [customers!]!
}

"""
aggregate fields of "customers"
"""
type customers_aggregate_fields {
  avg: customers_avg_fields
  count(columns: [customers_select_column!], distinct: Boolean): Int!
  max: customers_max_fields
  min: customers_min_fields
  stddev: customers_stddev_fields
  stddev_pop: customers_stddev_pop_fields
  stddev_samp: customers_stddev_samp_fields
  sum: customers_sum_fields
  var_pop: customers_var_pop_fields
  var_samp: customers_var_samp_fields
  variance: customers_variance_fields
}

"""
order by aggregate values of table "customers"
"""
input customers_aggregate_order_by {
  avg: customers_avg_order_by
  count: order_by
  max: customers_max_order_by
  min: customers_min_order_by
  stddev: customers_stddev_order_by
  stddev_pop: customers_stddev_pop_order_by
  stddev_samp: customers_stddev_samp_order_by
  sum: customers_sum_order_by
  var_pop: customers_var_pop_order_by
  var_samp: customers_var_samp_order_by
  variance: customers_variance_order_by
}

"""
input type for inserting array relation for remote table "customers"
"""
input customers_arr_rel_insert_input {
  data: [customers_insert_input!]!

  """on conflict condition"""
  on_conflict: customers_on_conflict
}

"""aggregate avg on columns"""
type customers_avg_fields {
  refresh_token_validity: Float
}

"""
order by avg() on columns of table "customers"
"""
input customers_avg_order_by {
  refresh_token_validity: order_by
}

"""
Boolean expression to filter rows from the table "customers". All fields are combined with a logical 'AND'.
"""
input customers_bool_exp {
  _and: [customers_bool_exp!]
  _not: customers_bool_exp
  _or: [customers_bool_exp!]
  conn_string: String_comparison_exp
  connector: connectors_enum_comparison_exp
  connectorByConnector: connectors_bool_exp
  created_at: timestamptz_comparison_exp
  customer_srv_urls: srv_urls_bool_exp
  customer_user_services: customer_user_service_bool_exp
  customer_user_sub_services: customer_user_sub_service_bool_exp
  customer_users: customer_user_bool_exp
  customers_contact: customers_contact_bool_exp
  deleted_at: timestamptz_comparison_exp
  features: features_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  org_nr: String_comparison_exp
  partner: partners_bool_exp
  partner_id: uuid_comparison_exp
  refresh_token_validity: Int_comparison_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  updated_at: timestamptz_comparison_exp
  users_auth_logs: users_auth_logs_bool_exp
}

"""
unique or primary key constraints on table "customers"
"""
enum customers_constraint {
  """unique or primary key constraint"""
  customers_name_key

  """unique or primary key constraint"""
  customers_org_nr_key

  """unique or primary key constraint"""
  customers_pkey
}

"""
columns and relationships of "customers_contact"
"""
type customers_contact {
  comm_consents_descr: String

  """An object relationship"""
  customer: customers!
  customer_id: uuid!
  email: String
  logo: String
  message: String
  tel: String
}

"""
aggregated selection of "customers_contact"
"""
type customers_contact_aggregate {
  aggregate: customers_contact_aggregate_fields
  nodes: [customers_contact!]!
}

"""
aggregate fields of "customers_contact"
"""
type customers_contact_aggregate_fields {
  count(columns: [customers_contact_select_column!], distinct: Boolean): Int!
  max: customers_contact_max_fields
  min: customers_contact_min_fields
}

"""
Boolean expression to filter rows from the table "customers_contact". All fields are combined with a logical 'AND'.
"""
input customers_contact_bool_exp {
  _and: [customers_contact_bool_exp!]
  _not: customers_contact_bool_exp
  _or: [customers_contact_bool_exp!]
  comm_consents_descr: String_comparison_exp
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  email: String_comparison_exp
  logo: String_comparison_exp
  message: String_comparison_exp
  tel: String_comparison_exp
}

"""
unique or primary key constraints on table "customers_contact"
"""
enum customers_contact_constraint {
  """unique or primary key constraint"""
  customers_contact_customer_id_key

  """unique or primary key constraint"""
  customers_contact_pkey
}

"""
input type for inserting data into table "customers_contact"
"""
input customers_contact_insert_input {
  comm_consents_descr: String
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  email: String
  logo: String
  message: String
  tel: String
}

"""aggregate max on columns"""
type customers_contact_max_fields {
  comm_consents_descr: String
  customer_id: uuid
  email: String
  logo: String
  message: String
  tel: String
}

"""aggregate min on columns"""
type customers_contact_min_fields {
  comm_consents_descr: String
  customer_id: uuid
  email: String
  logo: String
  message: String
  tel: String
}

"""
response of any mutation on the table "customers_contact"
"""
type customers_contact_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customers_contact!]!
}

"""
input type for inserting object relation for remote table "customers_contact"
"""
input customers_contact_obj_rel_insert_input {
  data: customers_contact_insert_input!

  """on conflict condition"""
  on_conflict: customers_contact_on_conflict
}

"""
on conflict condition type for table "customers_contact"
"""
input customers_contact_on_conflict {
  constraint: customers_contact_constraint!
  update_columns: [customers_contact_update_column!]! = []
  where: customers_contact_bool_exp
}

"""Ordering options when selecting data from "customers_contact"."""
input customers_contact_order_by {
  comm_consents_descr: order_by
  customer: customers_order_by
  customer_id: order_by
  email: order_by
  logo: order_by
  message: order_by
  tel: order_by
}

"""primary key columns input for table: customers_contact"""
input customers_contact_pk_columns_input {
  customer_id: uuid!
}

"""
select columns of table "customers_contact"
"""
enum customers_contact_select_column {
  """column name"""
  comm_consents_descr

  """column name"""
  customer_id

  """column name"""
  email

  """column name"""
  logo

  """column name"""
  message

  """column name"""
  tel
}

"""
input type for updating data in table "customers_contact"
"""
input customers_contact_set_input {
  comm_consents_descr: String
  customer_id: uuid
  email: String
  logo: String
  message: String
  tel: String
}

"""
update columns of table "customers_contact"
"""
enum customers_contact_update_column {
  """column name"""
  comm_consents_descr

  """column name"""
  customer_id

  """column name"""
  email

  """column name"""
  logo

  """column name"""
  message

  """column name"""
  tel
}

"""
input type for incrementing numeric columns in table "customers"
"""
input customers_inc_input {
  refresh_token_validity: Int
}

"""
input type for inserting data into table "customers"
"""
input customers_insert_input {
  conn_string: String
  connector: connectors_enum
  connectorByConnector: connectors_obj_rel_insert_input
  created_at: timestamptz
  customer_srv_urls: srv_urls_arr_rel_insert_input
  customer_user_services: customer_user_service_arr_rel_insert_input
  customer_user_sub_services: customer_user_sub_service_arr_rel_insert_input
  customer_users: customer_user_arr_rel_insert_input
  customers_contact: customers_contact_obj_rel_insert_input
  deleted_at: timestamptz
  features: features_arr_rel_insert_input
  id: uuid
  name: String
  org_nr: String
  partner: partners_obj_rel_insert_input
  partner_id: uuid
  refresh_token_validity: Int
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  updated_at: timestamptz
  users_auth_logs: users_auth_logs_arr_rel_insert_input
}

"""aggregate max on columns"""
type customers_max_fields {
  conn_string: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  org_nr: String
  partner_id: uuid
  refresh_token_validity: Int
  updated_at: timestamptz
}

"""
order by max() on columns of table "customers"
"""
input customers_max_order_by {
  conn_string: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  org_nr: order_by
  partner_id: order_by
  refresh_token_validity: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type customers_min_fields {
  conn_string: String
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  org_nr: String
  partner_id: uuid
  refresh_token_validity: Int
  updated_at: timestamptz
}

"""
order by min() on columns of table "customers"
"""
input customers_min_order_by {
  conn_string: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  name: order_by
  org_nr: order_by
  partner_id: order_by
  refresh_token_validity: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "customers"
"""
type customers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customers!]!
}

"""
input type for inserting object relation for remote table "customers"
"""
input customers_obj_rel_insert_input {
  data: customers_insert_input!

  """on conflict condition"""
  on_conflict: customers_on_conflict
}

"""
on conflict condition type for table "customers"
"""
input customers_on_conflict {
  constraint: customers_constraint!
  update_columns: [customers_update_column!]! = []
  where: customers_bool_exp
}

"""Ordering options when selecting data from "customers"."""
input customers_order_by {
  conn_string: order_by
  connector: order_by
  connectorByConnector: connectors_order_by
  created_at: order_by
  customer_srv_urls_aggregate: srv_urls_aggregate_order_by
  customer_user_services_aggregate: customer_user_service_aggregate_order_by
  customer_user_sub_services_aggregate: customer_user_sub_service_aggregate_order_by
  customer_users_aggregate: customer_user_aggregate_order_by
  customers_contact: customers_contact_order_by
  deleted_at: order_by
  features_aggregate: features_aggregate_order_by
  id: order_by
  name: order_by
  org_nr: order_by
  partner: partners_order_by
  partner_id: order_by
  refresh_token_validity: order_by
  status: order_by
  statusByStatus: status_order_by
  updated_at: order_by
  users_auth_logs_aggregate: users_auth_logs_aggregate_order_by
}

"""primary key columns input for table: customers"""
input customers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "customers"
"""
enum customers_select_column {
  """column name"""
  conn_string

  """column name"""
  connector

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  org_nr

  """column name"""
  partner_id

  """column name"""
  refresh_token_validity

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "customers"
"""
input customers_set_input {
  conn_string: String
  connector: connectors_enum
  created_at: timestamptz
  deleted_at: timestamptz
  id: uuid
  name: String
  org_nr: String
  partner_id: uuid
  refresh_token_validity: Int
  status: status_enum
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type customers_stddev_fields {
  refresh_token_validity: Float
}

"""
order by stddev() on columns of table "customers"
"""
input customers_stddev_order_by {
  refresh_token_validity: order_by
}

"""aggregate stddev_pop on columns"""
type customers_stddev_pop_fields {
  refresh_token_validity: Float
}

"""
order by stddev_pop() on columns of table "customers"
"""
input customers_stddev_pop_order_by {
  refresh_token_validity: order_by
}

"""aggregate stddev_samp on columns"""
type customers_stddev_samp_fields {
  refresh_token_validity: Float
}

"""
order by stddev_samp() on columns of table "customers"
"""
input customers_stddev_samp_order_by {
  refresh_token_validity: order_by
}

"""aggregate sum on columns"""
type customers_sum_fields {
  refresh_token_validity: Int
}

"""
order by sum() on columns of table "customers"
"""
input customers_sum_order_by {
  refresh_token_validity: order_by
}

"""
update columns of table "customers"
"""
enum customers_update_column {
  """column name"""
  conn_string

  """column name"""
  connector

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  org_nr

  """column name"""
  partner_id

  """column name"""
  refresh_token_validity

  """column name"""
  status

  """column name"""
  updated_at
}

"""aggregate var_pop on columns"""
type customers_var_pop_fields {
  refresh_token_validity: Float
}

"""
order by var_pop() on columns of table "customers"
"""
input customers_var_pop_order_by {
  refresh_token_validity: order_by
}

"""aggregate var_samp on columns"""
type customers_var_samp_fields {
  refresh_token_validity: Float
}

"""
order by var_samp() on columns of table "customers"
"""
input customers_var_samp_order_by {
  refresh_token_validity: order_by
}

"""aggregate variance on columns"""
type customers_variance_fields {
  refresh_token_validity: Float
}

"""
order by variance() on columns of table "customers"
"""
input customers_variance_order_by {
  refresh_token_validity: order_by
}

"""
columns and relationships of "feature_names"
"""
type feature_names {
  description: String

  """An array relationship"""
  features(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): [features!]!

  """An aggregate relationship"""
  features_aggregate(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): features_aggregate!
  name: String!
}

"""
aggregated selection of "feature_names"
"""
type feature_names_aggregate {
  aggregate: feature_names_aggregate_fields
  nodes: [feature_names!]!
}

"""
aggregate fields of "feature_names"
"""
type feature_names_aggregate_fields {
  count(columns: [feature_names_select_column!], distinct: Boolean): Int!
  max: feature_names_max_fields
  min: feature_names_min_fields
}

"""
Boolean expression to filter rows from the table "feature_names". All fields are combined with a logical 'AND'.
"""
input feature_names_bool_exp {
  _and: [feature_names_bool_exp!]
  _not: feature_names_bool_exp
  _or: [feature_names_bool_exp!]
  description: String_comparison_exp
  features: features_bool_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "feature_names"
"""
enum feature_names_constraint {
  """unique or primary key constraint"""
  feature_names_pkey
}

enum feature_names_enum {
  anonymousQnr
  autoImportableQnr
  dashboardTraceability
  ordersOverviewOnSelectedRecipientsForQnr
  predefinedUserForQnr
  rejectableQnr
  signByTherapistDocument

  """info about test"""
  test
}

"""
Boolean expression to compare columns of type "feature_names_enum". All fields are combined with logical 'AND'.
"""
input feature_names_enum_comparison_exp {
  _eq: feature_names_enum
  _in: [feature_names_enum!]
  _is_null: Boolean
  _neq: feature_names_enum
  _nin: [feature_names_enum!]
}

"""
input type for inserting data into table "feature_names"
"""
input feature_names_insert_input {
  description: String
  features: features_arr_rel_insert_input
  name: String
}

"""aggregate max on columns"""
type feature_names_max_fields {
  description: String
  name: String
}

"""aggregate min on columns"""
type feature_names_min_fields {
  description: String
  name: String
}

"""
response of any mutation on the table "feature_names"
"""
type feature_names_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feature_names!]!
}

"""
input type for inserting object relation for remote table "feature_names"
"""
input feature_names_obj_rel_insert_input {
  data: feature_names_insert_input!

  """on conflict condition"""
  on_conflict: feature_names_on_conflict
}

"""
on conflict condition type for table "feature_names"
"""
input feature_names_on_conflict {
  constraint: feature_names_constraint!
  update_columns: [feature_names_update_column!]! = []
  where: feature_names_bool_exp
}

"""Ordering options when selecting data from "feature_names"."""
input feature_names_order_by {
  description: order_by
  features_aggregate: features_aggregate_order_by
  name: order_by
}

"""primary key columns input for table: feature_names"""
input feature_names_pk_columns_input {
  name: String!
}

"""
select columns of table "feature_names"
"""
enum feature_names_select_column {
  """column name"""
  description

  """column name"""
  name
}

"""
input type for updating data in table "feature_names"
"""
input feature_names_set_input {
  description: String
  name: String
}

"""
update columns of table "feature_names"
"""
enum feature_names_update_column {
  """column name"""
  description

  """column name"""
  name
}

"""
columns and relationships of "features"
"""
type features {
  """An object relationship"""
  customer: customers!
  customer_id: uuid!

  """An object relationship"""
  feature_name: feature_names!
  name: feature_names_enum!
}

"""
aggregated selection of "features"
"""
type features_aggregate {
  aggregate: features_aggregate_fields
  nodes: [features!]!
}

"""
aggregate fields of "features"
"""
type features_aggregate_fields {
  count(columns: [features_select_column!], distinct: Boolean): Int!
  max: features_max_fields
  min: features_min_fields
}

"""
order by aggregate values of table "features"
"""
input features_aggregate_order_by {
  count: order_by
  max: features_max_order_by
  min: features_min_order_by
}

"""
input type for inserting array relation for remote table "features"
"""
input features_arr_rel_insert_input {
  data: [features_insert_input!]!

  """on conflict condition"""
  on_conflict: features_on_conflict
}

"""
Boolean expression to filter rows from the table "features". All fields are combined with a logical 'AND'.
"""
input features_bool_exp {
  _and: [features_bool_exp!]
  _not: features_bool_exp
  _or: [features_bool_exp!]
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  feature_name: feature_names_bool_exp
  name: feature_names_enum_comparison_exp
}

"""
unique or primary key constraints on table "features"
"""
enum features_constraint {
  """unique or primary key constraint"""
  features_pkey
}

"""
input type for inserting data into table "features"
"""
input features_insert_input {
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  feature_name: feature_names_obj_rel_insert_input
  name: feature_names_enum
}

"""aggregate max on columns"""
type features_max_fields {
  customer_id: uuid
}

"""
order by max() on columns of table "features"
"""
input features_max_order_by {
  customer_id: order_by
}

"""aggregate min on columns"""
type features_min_fields {
  customer_id: uuid
}

"""
order by min() on columns of table "features"
"""
input features_min_order_by {
  customer_id: order_by
}

"""
response of any mutation on the table "features"
"""
type features_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [features!]!
}

"""
on conflict condition type for table "features"
"""
input features_on_conflict {
  constraint: features_constraint!
  update_columns: [features_update_column!]! = []
  where: features_bool_exp
}

"""Ordering options when selecting data from "features"."""
input features_order_by {
  customer: customers_order_by
  customer_id: order_by
  feature_name: feature_names_order_by
  name: order_by
}

"""primary key columns input for table: features"""
input features_pk_columns_input {
  customer_id: uuid!
  name: feature_names_enum!
}

"""
select columns of table "features"
"""
enum features_select_column {
  """column name"""
  customer_id

  """column name"""
  name
}

"""
input type for updating data in table "features"
"""
input features_set_input {
  customer_id: uuid
  name: feature_names_enum
}

"""
update columns of table "features"
"""
enum features_update_column {
  """column name"""
  customer_id

  """column name"""
  name
}

type getCustomersAndCountUsersOutput {
  conn_string: String!
  connector: String!

  """An array relationship"""
  customerFeatures(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): [features!]!

  """An aggregate relationship"""
  customerFeatures_aggregate(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): features_aggregate!

  """An array relationship"""
  customerSrvUrls(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): [srv_urls!]!

  """An aggregate relationship"""
  customerSrvUrls_aggregate(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): srv_urls_aggregate!

  """An object relationship"""
  customersContact: customers_contact!
  id: String!
  name: String!
  refresh_token_validity: Int!
  users_count: Int
  x_api_key: String!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "admins"
  """
  delete_admins(
    """filter the rows which have to be deleted"""
    where: admins_bool_exp!
  ): admins_mutation_response

  """
  delete data from the table: "admins_auth_logs"
  """
  delete_admins_auth_logs(
    """filter the rows which have to be deleted"""
    where: admins_auth_logs_bool_exp!
  ): admins_auth_logs_mutation_response

  """
  delete single row from the table: "admins_auth_logs"
  """
  delete_admins_auth_logs_by_pk(id: Int!): admins_auth_logs

  """
  delete single row from the table: "admins"
  """
  delete_admins_by_pk(id: uuid!): admins

  """
  delete data from the table: "auth_methods"
  """
  delete_auth_methods(
    """filter the rows which have to be deleted"""
    where: auth_methods_bool_exp!
  ): auth_methods_mutation_response

  """
  delete single row from the table: "auth_methods"
  """
  delete_auth_methods_by_pk(name: String!): auth_methods

  """
  delete data from the table: "blacklist_refresh_token"
  """
  delete_blacklist_refresh_token(
    """filter the rows which have to be deleted"""
    where: blacklist_refresh_token_bool_exp!
  ): blacklist_refresh_token_mutation_response

  """
  delete single row from the table: "blacklist_refresh_token"
  """
  delete_blacklist_refresh_token_by_pk(sig: String!): blacklist_refresh_token

  """
  delete data from the table: "connectors"
  """
  delete_connectors(
    """filter the rows which have to be deleted"""
    where: connectors_bool_exp!
  ): connectors_mutation_response

  """
  delete single row from the table: "connectors"
  """
  delete_connectors_by_pk(name: String!): connectors

  """
  delete data from the table: "customer_user"
  """
  delete_customer_user(
    """filter the rows which have to be deleted"""
    where: customer_user_bool_exp!
  ): customer_user_mutation_response

  """
  delete single row from the table: "customer_user"
  """
  delete_customer_user_by_pk(customer_id: uuid!, user_id: uuid!): customer_user

  """
  delete data from the table: "customer_user_service"
  """
  delete_customer_user_service(
    """filter the rows which have to be deleted"""
    where: customer_user_service_bool_exp!
  ): customer_user_service_mutation_response

  """
  delete single row from the table: "customer_user_service"
  """
  delete_customer_user_service_by_pk(customer_id: uuid!, service: services_enum!, user_id: uuid!): customer_user_service

  """
  delete data from the table: "customer_user_sub_service"
  """
  delete_customer_user_sub_service(
    """filter the rows which have to be deleted"""
    where: customer_user_sub_service_bool_exp!
  ): customer_user_sub_service_mutation_response

  """
  delete single row from the table: "customer_user_sub_service"
  """
  delete_customer_user_sub_service_by_pk(customer_id: uuid!, service: services_enum!, sub_service: String!, user_id: uuid!): customer_user_sub_service

  """
  delete data from the table: "customers"
  """
  delete_customers(
    """filter the rows which have to be deleted"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  delete single row from the table: "customers"
  """
  delete_customers_by_pk(id: uuid!): customers

  """
  delete data from the table: "customers_contact"
  """
  delete_customers_contact(
    """filter the rows which have to be deleted"""
    where: customers_contact_bool_exp!
  ): customers_contact_mutation_response

  """
  delete single row from the table: "customers_contact"
  """
  delete_customers_contact_by_pk(customer_id: uuid!): customers_contact

  """
  delete data from the table: "feature_names"
  """
  delete_feature_names(
    """filter the rows which have to be deleted"""
    where: feature_names_bool_exp!
  ): feature_names_mutation_response

  """
  delete single row from the table: "feature_names"
  """
  delete_feature_names_by_pk(name: String!): feature_names

  """
  delete data from the table: "features"
  """
  delete_features(
    """filter the rows which have to be deleted"""
    where: features_bool_exp!
  ): features_mutation_response

  """
  delete single row from the table: "features"
  """
  delete_features_by_pk(customer_id: uuid!, name: feature_names_enum!): features

  """
  delete data from the table: "partners"
  """
  delete_partners(
    """filter the rows which have to be deleted"""
    where: partners_bool_exp!
  ): partners_mutation_response

  """
  delete single row from the table: "partners"
  """
  delete_partners_by_pk(id: uuid!): partners

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(name: String!): roles

  """
  delete data from the table: "services"
  """
  delete_services(
    """filter the rows which have to be deleted"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  delete single row from the table: "services"
  """
  delete_services_by_pk(name: String!): services

  """
  delete data from the table: "srv_names"
  """
  delete_srv_names(
    """filter the rows which have to be deleted"""
    where: srv_names_bool_exp!
  ): srv_names_mutation_response

  """
  delete single row from the table: "srv_names"
  """
  delete_srv_names_by_pk(name: String!): srv_names

  """
  delete data from the table: "srv_urls"
  """
  delete_srv_urls(
    """filter the rows which have to be deleted"""
    where: srv_urls_bool_exp!
  ): srv_urls_mutation_response

  """
  delete single row from the table: "srv_urls"
  """
  delete_srv_urls_by_pk(customer_id: uuid!, name: srv_names_enum!): srv_urls

  """
  delete data from the table: "status"
  """
  delete_status(
    """filter the rows which have to be deleted"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  delete single row from the table: "status"
  """
  delete_status_by_pk(name: String!): status

  """
  delete data from the table: "sub_services"
  """
  delete_sub_services(
    """filter the rows which have to be deleted"""
    where: sub_services_bool_exp!
  ): sub_services_mutation_response

  """
  delete single row from the table: "sub_services"
  """
  delete_sub_services_by_pk(name: String!, service: services_enum!): sub_services

  """
  delete data from the table: "user_basic_data"
  """
  delete_user_basic_data(
    """filter the rows which have to be deleted"""
    where: user_basic_data_bool_exp!
  ): user_basic_data_mutation_response

  """
  delete single row from the table: "user_basic_data"
  """
  delete_user_basic_data_by_pk(user_id: uuid!): user_basic_data

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete data from the table: "users_auth_logs"
  """
  delete_users_auth_logs(
    """filter the rows which have to be deleted"""
    where: users_auth_logs_bool_exp!
  ): users_auth_logs_mutation_response

  """
  delete single row from the table: "users_auth_logs"
  """
  delete_users_auth_logs_by_pk(id: Int!): users_auth_logs

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users
  insertAdmin(email: bpchar!, name: bpchar!, password: bpchar!, phone: String!): ReturnAffectedItemId
  insertCustomer(conn_string: String!, connector: String, contact_email: String, contact_message: String, contact_tel: String, name: String!, refresh_token_validity: Int!): getCustomersAndCountUsersOutput
  insertUserOrWarnIfExists(brukerBrukerNavn: String, brukerRegion: Int, customer_id: uuid, email: String!, name: String!, password: String!, phone: String!, role: String, token: String): InsertUserOrWarnIfExistsOutput
  insertUsersOrWarnIfExists(objects: [InsertUserData!]): InsertUserOrWarnIfExistsOutput

  """
  insert data into the table: "admins"
  """
  insert_admins(
    """the rows to be inserted"""
    objects: [admins_insert_input!]!

    """on conflict condition"""
    on_conflict: admins_on_conflict
  ): admins_mutation_response

  """
  insert data into the table: "admins_auth_logs"
  """
  insert_admins_auth_logs(
    """the rows to be inserted"""
    objects: [admins_auth_logs_insert_input!]!

    """on conflict condition"""
    on_conflict: admins_auth_logs_on_conflict
  ): admins_auth_logs_mutation_response

  """
  insert a single row into the table: "admins_auth_logs"
  """
  insert_admins_auth_logs_one(
    """the row to be inserted"""
    object: admins_auth_logs_insert_input!

    """on conflict condition"""
    on_conflict: admins_auth_logs_on_conflict
  ): admins_auth_logs

  """
  insert a single row into the table: "admins"
  """
  insert_admins_one(
    """the row to be inserted"""
    object: admins_insert_input!

    """on conflict condition"""
    on_conflict: admins_on_conflict
  ): admins

  """
  insert data into the table: "auth_methods"
  """
  insert_auth_methods(
    """the rows to be inserted"""
    objects: [auth_methods_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_methods_on_conflict
  ): auth_methods_mutation_response

  """
  insert a single row into the table: "auth_methods"
  """
  insert_auth_methods_one(
    """the row to be inserted"""
    object: auth_methods_insert_input!

    """on conflict condition"""
    on_conflict: auth_methods_on_conflict
  ): auth_methods

  """
  insert data into the table: "blacklist_refresh_token"
  """
  insert_blacklist_refresh_token(
    """the rows to be inserted"""
    objects: [blacklist_refresh_token_insert_input!]!

    """on conflict condition"""
    on_conflict: blacklist_refresh_token_on_conflict
  ): blacklist_refresh_token_mutation_response

  """
  insert a single row into the table: "blacklist_refresh_token"
  """
  insert_blacklist_refresh_token_one(
    """the row to be inserted"""
    object: blacklist_refresh_token_insert_input!

    """on conflict condition"""
    on_conflict: blacklist_refresh_token_on_conflict
  ): blacklist_refresh_token

  """
  insert data into the table: "connectors"
  """
  insert_connectors(
    """the rows to be inserted"""
    objects: [connectors_insert_input!]!

    """on conflict condition"""
    on_conflict: connectors_on_conflict
  ): connectors_mutation_response

  """
  insert a single row into the table: "connectors"
  """
  insert_connectors_one(
    """the row to be inserted"""
    object: connectors_insert_input!

    """on conflict condition"""
    on_conflict: connectors_on_conflict
  ): connectors

  """
  insert data into the table: "customer_user"
  """
  insert_customer_user(
    """the rows to be inserted"""
    objects: [customer_user_insert_input!]!

    """on conflict condition"""
    on_conflict: customer_user_on_conflict
  ): customer_user_mutation_response

  """
  insert a single row into the table: "customer_user"
  """
  insert_customer_user_one(
    """the row to be inserted"""
    object: customer_user_insert_input!

    """on conflict condition"""
    on_conflict: customer_user_on_conflict
  ): customer_user

  """
  insert data into the table: "customer_user_service"
  """
  insert_customer_user_service(
    """the rows to be inserted"""
    objects: [customer_user_service_insert_input!]!

    """on conflict condition"""
    on_conflict: customer_user_service_on_conflict
  ): customer_user_service_mutation_response

  """
  insert a single row into the table: "customer_user_service"
  """
  insert_customer_user_service_one(
    """the row to be inserted"""
    object: customer_user_service_insert_input!

    """on conflict condition"""
    on_conflict: customer_user_service_on_conflict
  ): customer_user_service

  """
  insert data into the table: "customer_user_sub_service"
  """
  insert_customer_user_sub_service(
    """the rows to be inserted"""
    objects: [customer_user_sub_service_insert_input!]!

    """on conflict condition"""
    on_conflict: customer_user_sub_service_on_conflict
  ): customer_user_sub_service_mutation_response

  """
  insert a single row into the table: "customer_user_sub_service"
  """
  insert_customer_user_sub_service_one(
    """the row to be inserted"""
    object: customer_user_sub_service_insert_input!

    """on conflict condition"""
    on_conflict: customer_user_sub_service_on_conflict
  ): customer_user_sub_service

  """
  insert data into the table: "customers"
  """
  insert_customers(
    """the rows to be inserted"""
    objects: [customers_insert_input!]!

    """on conflict condition"""
    on_conflict: customers_on_conflict
  ): customers_mutation_response

  """
  insert data into the table: "customers_contact"
  """
  insert_customers_contact(
    """the rows to be inserted"""
    objects: [customers_contact_insert_input!]!

    """on conflict condition"""
    on_conflict: customers_contact_on_conflict
  ): customers_contact_mutation_response

  """
  insert a single row into the table: "customers_contact"
  """
  insert_customers_contact_one(
    """the row to be inserted"""
    object: customers_contact_insert_input!

    """on conflict condition"""
    on_conflict: customers_contact_on_conflict
  ): customers_contact

  """
  insert a single row into the table: "customers"
  """
  insert_customers_one(
    """the row to be inserted"""
    object: customers_insert_input!

    """on conflict condition"""
    on_conflict: customers_on_conflict
  ): customers

  """
  insert data into the table: "feature_names"
  """
  insert_feature_names(
    """the rows to be inserted"""
    objects: [feature_names_insert_input!]!

    """on conflict condition"""
    on_conflict: feature_names_on_conflict
  ): feature_names_mutation_response

  """
  insert a single row into the table: "feature_names"
  """
  insert_feature_names_one(
    """the row to be inserted"""
    object: feature_names_insert_input!

    """on conflict condition"""
    on_conflict: feature_names_on_conflict
  ): feature_names

  """
  insert data into the table: "features"
  """
  insert_features(
    """the rows to be inserted"""
    objects: [features_insert_input!]!

    """on conflict condition"""
    on_conflict: features_on_conflict
  ): features_mutation_response

  """
  insert a single row into the table: "features"
  """
  insert_features_one(
    """the row to be inserted"""
    object: features_insert_input!

    """on conflict condition"""
    on_conflict: features_on_conflict
  ): features

  """
  insert data into the table: "partners"
  """
  insert_partners(
    """the rows to be inserted"""
    objects: [partners_insert_input!]!

    """on conflict condition"""
    on_conflict: partners_on_conflict
  ): partners_mutation_response

  """
  insert a single row into the table: "partners"
  """
  insert_partners_one(
    """the row to be inserted"""
    object: partners_insert_input!

    """on conflict condition"""
    on_conflict: partners_on_conflict
  ): partners

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """on conflict condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "services"
  """
  insert_services(
    """the rows to be inserted"""
    objects: [services_insert_input!]!

    """on conflict condition"""
    on_conflict: services_on_conflict
  ): services_mutation_response

  """
  insert a single row into the table: "services"
  """
  insert_services_one(
    """the row to be inserted"""
    object: services_insert_input!

    """on conflict condition"""
    on_conflict: services_on_conflict
  ): services

  """
  insert data into the table: "srv_names"
  """
  insert_srv_names(
    """the rows to be inserted"""
    objects: [srv_names_insert_input!]!

    """on conflict condition"""
    on_conflict: srv_names_on_conflict
  ): srv_names_mutation_response

  """
  insert a single row into the table: "srv_names"
  """
  insert_srv_names_one(
    """the row to be inserted"""
    object: srv_names_insert_input!

    """on conflict condition"""
    on_conflict: srv_names_on_conflict
  ): srv_names

  """
  insert data into the table: "srv_urls"
  """
  insert_srv_urls(
    """the rows to be inserted"""
    objects: [srv_urls_insert_input!]!

    """on conflict condition"""
    on_conflict: srv_urls_on_conflict
  ): srv_urls_mutation_response

  """
  insert a single row into the table: "srv_urls"
  """
  insert_srv_urls_one(
    """the row to be inserted"""
    object: srv_urls_insert_input!

    """on conflict condition"""
    on_conflict: srv_urls_on_conflict
  ): srv_urls

  """
  insert data into the table: "status"
  """
  insert_status(
    """the rows to be inserted"""
    objects: [status_insert_input!]!

    """on conflict condition"""
    on_conflict: status_on_conflict
  ): status_mutation_response

  """
  insert a single row into the table: "status"
  """
  insert_status_one(
    """the row to be inserted"""
    object: status_insert_input!

    """on conflict condition"""
    on_conflict: status_on_conflict
  ): status

  """
  insert data into the table: "sub_services"
  """
  insert_sub_services(
    """the rows to be inserted"""
    objects: [sub_services_insert_input!]!

    """on conflict condition"""
    on_conflict: sub_services_on_conflict
  ): sub_services_mutation_response

  """
  insert a single row into the table: "sub_services"
  """
  insert_sub_services_one(
    """the row to be inserted"""
    object: sub_services_insert_input!

    """on conflict condition"""
    on_conflict: sub_services_on_conflict
  ): sub_services

  """
  insert data into the table: "user_basic_data"
  """
  insert_user_basic_data(
    """the rows to be inserted"""
    objects: [user_basic_data_insert_input!]!

    """on conflict condition"""
    on_conflict: user_basic_data_on_conflict
  ): user_basic_data_mutation_response

  """
  insert a single row into the table: "user_basic_data"
  """
  insert_user_basic_data_one(
    """the row to be inserted"""
    object: user_basic_data_insert_input!

    """on conflict condition"""
    on_conflict: user_basic_data_on_conflict
  ): user_basic_data

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert data into the table: "users_auth_logs"
  """
  insert_users_auth_logs(
    """the rows to be inserted"""
    objects: [users_auth_logs_insert_input!]!

    """on conflict condition"""
    on_conflict: users_auth_logs_on_conflict
  ): users_auth_logs_mutation_response

  """
  insert a single row into the table: "users_auth_logs"
  """
  insert_users_auth_logs_one(
    """the row to be inserted"""
    object: users_auth_logs_insert_input!

    """on conflict condition"""
    on_conflict: users_auth_logs_on_conflict
  ): users_auth_logs

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users
  signin(customer_name: String!, email: String!, password: String!): SigninOutput
  singinAvansAdmin(email: String!, password: String!): SinginOutputWithRefreshToken
  singinAvansAdminByRefreshToken(id: uuid!): SinginOutputWithRefreshToken
  updateAdmin(email: bpchar!, id: uuid!, name: bpchar!, password: bpchar!, phone: String!): ReturnAffectedItemId
  updateCustomer(conn_string: String, connector: String!, contact_email: String, contact_message: String, contact_tel: String, id: uuid!, name: String!, refresh_token_validity: Int!): ReturnAffectedRows
  updateUser(email: bpchar, id: uuid!, name: bpchar, password: bpchar, phone: String, role: String): UpdateUserOutput

  """
  update data of the table: "admins"
  """
  update_admins(
    """sets the columns of the filtered rows to the given values"""
    _set: admins_set_input

    """filter the rows which have to be updated"""
    where: admins_bool_exp!
  ): admins_mutation_response

  """
  update data of the table: "admins_auth_logs"
  """
  update_admins_auth_logs(
    """increments the numeric columns with given value of the filtered values"""
    _inc: admins_auth_logs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: admins_auth_logs_set_input

    """filter the rows which have to be updated"""
    where: admins_auth_logs_bool_exp!
  ): admins_auth_logs_mutation_response

  """
  update single row of the table: "admins_auth_logs"
  """
  update_admins_auth_logs_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: admins_auth_logs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: admins_auth_logs_set_input
    pk_columns: admins_auth_logs_pk_columns_input!
  ): admins_auth_logs

  """
  update single row of the table: "admins"
  """
  update_admins_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: admins_set_input
    pk_columns: admins_pk_columns_input!
  ): admins

  """
  update data of the table: "auth_methods"
  """
  update_auth_methods(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_methods_set_input

    """filter the rows which have to be updated"""
    where: auth_methods_bool_exp!
  ): auth_methods_mutation_response

  """
  update single row of the table: "auth_methods"
  """
  update_auth_methods_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_methods_set_input
    pk_columns: auth_methods_pk_columns_input!
  ): auth_methods

  """
  update data of the table: "blacklist_refresh_token"
  """
  update_blacklist_refresh_token(
    """sets the columns of the filtered rows to the given values"""
    _set: blacklist_refresh_token_set_input

    """filter the rows which have to be updated"""
    where: blacklist_refresh_token_bool_exp!
  ): blacklist_refresh_token_mutation_response

  """
  update single row of the table: "blacklist_refresh_token"
  """
  update_blacklist_refresh_token_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: blacklist_refresh_token_set_input
    pk_columns: blacklist_refresh_token_pk_columns_input!
  ): blacklist_refresh_token

  """
  update data of the table: "connectors"
  """
  update_connectors(
    """sets the columns of the filtered rows to the given values"""
    _set: connectors_set_input

    """filter the rows which have to be updated"""
    where: connectors_bool_exp!
  ): connectors_mutation_response

  """
  update single row of the table: "connectors"
  """
  update_connectors_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: connectors_set_input
    pk_columns: connectors_pk_columns_input!
  ): connectors

  """
  update data of the table: "customer_user"
  """
  update_customer_user(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_user_set_input

    """filter the rows which have to be updated"""
    where: customer_user_bool_exp!
  ): customer_user_mutation_response

  """
  update single row of the table: "customer_user"
  """
  update_customer_user_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customer_user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customer_user_set_input
    pk_columns: customer_user_pk_columns_input!
  ): customer_user

  """
  update data of the table: "customer_user_service"
  """
  update_customer_user_service(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_user_service_set_input

    """filter the rows which have to be updated"""
    where: customer_user_service_bool_exp!
  ): customer_user_service_mutation_response

  """
  update single row of the table: "customer_user_service"
  """
  update_customer_user_service_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_user_service_set_input
    pk_columns: customer_user_service_pk_columns_input!
  ): customer_user_service

  """
  update data of the table: "customer_user_sub_service"
  """
  update_customer_user_sub_service(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_user_sub_service_set_input

    """filter the rows which have to be updated"""
    where: customer_user_sub_service_bool_exp!
  ): customer_user_sub_service_mutation_response

  """
  update single row of the table: "customer_user_sub_service"
  """
  update_customer_user_sub_service_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: customer_user_sub_service_set_input
    pk_columns: customer_user_sub_service_pk_columns_input!
  ): customer_user_sub_service

  """
  update data of the table: "customers"
  """
  update_customers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customers_set_input

    """filter the rows which have to be updated"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  update single row of the table: "customers"
  """
  update_customers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customers_set_input
    pk_columns: customers_pk_columns_input!
  ): customers

  """
  update data of the table: "customers_contact"
  """
  update_customers_contact(
    """sets the columns of the filtered rows to the given values"""
    _set: customers_contact_set_input

    """filter the rows which have to be updated"""
    where: customers_contact_bool_exp!
  ): customers_contact_mutation_response

  """
  update single row of the table: "customers_contact"
  """
  update_customers_contact_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: customers_contact_set_input
    pk_columns: customers_contact_pk_columns_input!
  ): customers_contact

  """
  update data of the table: "feature_names"
  """
  update_feature_names(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_names_set_input

    """filter the rows which have to be updated"""
    where: feature_names_bool_exp!
  ): feature_names_mutation_response

  """
  update single row of the table: "feature_names"
  """
  update_feature_names_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: feature_names_set_input
    pk_columns: feature_names_pk_columns_input!
  ): feature_names

  """
  update data of the table: "features"
  """
  update_features(
    """sets the columns of the filtered rows to the given values"""
    _set: features_set_input

    """filter the rows which have to be updated"""
    where: features_bool_exp!
  ): features_mutation_response

  """
  update single row of the table: "features"
  """
  update_features_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: features_set_input
    pk_columns: features_pk_columns_input!
  ): features

  """
  update data of the table: "partners"
  """
  update_partners(
    """sets the columns of the filtered rows to the given values"""
    _set: partners_set_input

    """filter the rows which have to be updated"""
    where: partners_bool_exp!
  ): partners_mutation_response

  """
  update single row of the table: "partners"
  """
  update_partners_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: partners_set_input
    pk_columns: partners_pk_columns_input!
  ): partners

  """
  update data of the table: "roles"
  """
  update_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update data of the table: "services"
  """
  update_services(
    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input

    """filter the rows which have to be updated"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  update single row of the table: "services"
  """
  update_services_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input
    pk_columns: services_pk_columns_input!
  ): services

  """
  update data of the table: "srv_names"
  """
  update_srv_names(
    """sets the columns of the filtered rows to the given values"""
    _set: srv_names_set_input

    """filter the rows which have to be updated"""
    where: srv_names_bool_exp!
  ): srv_names_mutation_response

  """
  update single row of the table: "srv_names"
  """
  update_srv_names_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: srv_names_set_input
    pk_columns: srv_names_pk_columns_input!
  ): srv_names

  """
  update data of the table: "srv_urls"
  """
  update_srv_urls(
    """sets the columns of the filtered rows to the given values"""
    _set: srv_urls_set_input

    """filter the rows which have to be updated"""
    where: srv_urls_bool_exp!
  ): srv_urls_mutation_response

  """
  update single row of the table: "srv_urls"
  """
  update_srv_urls_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: srv_urls_set_input
    pk_columns: srv_urls_pk_columns_input!
  ): srv_urls

  """
  update data of the table: "status"
  """
  update_status(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input

    """filter the rows which have to be updated"""
    where: status_bool_exp!
  ): status_mutation_response

  """
  update single row of the table: "status"
  """
  update_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: status_set_input
    pk_columns: status_pk_columns_input!
  ): status

  """
  update data of the table: "sub_services"
  """
  update_sub_services(
    """sets the columns of the filtered rows to the given values"""
    _set: sub_services_set_input

    """filter the rows which have to be updated"""
    where: sub_services_bool_exp!
  ): sub_services_mutation_response

  """
  update single row of the table: "sub_services"
  """
  update_sub_services_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: sub_services_set_input
    pk_columns: sub_services_pk_columns_input!
  ): sub_services

  """
  update data of the table: "user_basic_data"
  """
  update_user_basic_data(
    """sets the columns of the filtered rows to the given values"""
    _set: user_basic_data_set_input

    """filter the rows which have to be updated"""
    where: user_basic_data_bool_exp!
  ): user_basic_data_mutation_response

  """
  update single row of the table: "user_basic_data"
  """
  update_user_basic_data_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_basic_data_set_input
    pk_columns: user_basic_data_pk_columns_input!
  ): user_basic_data

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update data of the table: "users_auth_logs"
  """
  update_users_auth_logs(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_auth_logs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_auth_logs_set_input

    """filter the rows which have to be updated"""
    where: users_auth_logs_bool_exp!
  ): users_auth_logs_mutation_response

  """
  update single row of the table: "users_auth_logs"
  """
  update_users_auth_logs_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: users_auth_logs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_auth_logs_set_input
    pk_columns: users_auth_logs_pk_columns_input!
  ): users_auth_logs

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "partners"
"""
type partners {
  """An array relationship"""
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """An aggregate relationship"""
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!
  id: uuid!
  name: String!
}

"""
aggregated selection of "partners"
"""
type partners_aggregate {
  aggregate: partners_aggregate_fields
  nodes: [partners!]!
}

"""
aggregate fields of "partners"
"""
type partners_aggregate_fields {
  count(columns: [partners_select_column!], distinct: Boolean): Int!
  max: partners_max_fields
  min: partners_min_fields
}

"""
Boolean expression to filter rows from the table "partners". All fields are combined with a logical 'AND'.
"""
input partners_bool_exp {
  _and: [partners_bool_exp!]
  _not: partners_bool_exp
  _or: [partners_bool_exp!]
  customers: customers_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "partners"
"""
enum partners_constraint {
  """unique or primary key constraint"""
  partners_pkey
}

"""
input type for inserting data into table "partners"
"""
input partners_insert_input {
  customers: customers_arr_rel_insert_input
  id: uuid
  name: String
}

"""aggregate max on columns"""
type partners_max_fields {
  id: uuid
  name: String
}

"""aggregate min on columns"""
type partners_min_fields {
  id: uuid
  name: String
}

"""
response of any mutation on the table "partners"
"""
type partners_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [partners!]!
}

"""
input type for inserting object relation for remote table "partners"
"""
input partners_obj_rel_insert_input {
  data: partners_insert_input!

  """on conflict condition"""
  on_conflict: partners_on_conflict
}

"""
on conflict condition type for table "partners"
"""
input partners_on_conflict {
  constraint: partners_constraint!
  update_columns: [partners_update_column!]! = []
  where: partners_bool_exp
}

"""Ordering options when selecting data from "partners"."""
input partners_order_by {
  customers_aggregate: customers_aggregate_order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: partners"""
input partners_pk_columns_input {
  id: uuid!
}

"""
select columns of table "partners"
"""
enum partners_select_column {
  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "partners"
"""
input partners_set_input {
  id: uuid
  name: String
}

"""
update columns of table "partners"
"""
enum partners_update_column {
  """column name"""
  id

  """column name"""
  name
}

type query_root {
  """
  fetch data from the table: "admins"
  """
  admins(
    """distinct select on columns"""
    distinct_on: [admins_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_order_by!]

    """filter the rows returned"""
    where: admins_bool_exp
  ): [admins!]!

  """
  fetch aggregated fields from the table: "admins"
  """
  admins_aggregate(
    """distinct select on columns"""
    distinct_on: [admins_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_order_by!]

    """filter the rows returned"""
    where: admins_bool_exp
  ): admins_aggregate!

  """
  fetch data from the table: "admins_auth_logs"
  """
  admins_auth_logs(
    """distinct select on columns"""
    distinct_on: [admins_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_auth_logs_order_by!]

    """filter the rows returned"""
    where: admins_auth_logs_bool_exp
  ): [admins_auth_logs!]!

  """An aggregate relationship"""
  admins_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [admins_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_auth_logs_order_by!]

    """filter the rows returned"""
    where: admins_auth_logs_bool_exp
  ): admins_auth_logs_aggregate!

  """
  fetch data from the table: "admins_auth_logs" using primary key columns
  """
  admins_auth_logs_by_pk(id: Int!): admins_auth_logs

  """fetch data from the table: "admins" using primary key columns"""
  admins_by_pk(id: uuid!): admins

  """
  fetch data from the table: "auth_methods"
  """
  auth_methods(
    """distinct select on columns"""
    distinct_on: [auth_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_methods_order_by!]

    """filter the rows returned"""
    where: auth_methods_bool_exp
  ): [auth_methods!]!

  """
  fetch aggregated fields from the table: "auth_methods"
  """
  auth_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_methods_order_by!]

    """filter the rows returned"""
    where: auth_methods_bool_exp
  ): auth_methods_aggregate!

  """fetch data from the table: "auth_methods" using primary key columns"""
  auth_methods_by_pk(name: String!): auth_methods

  """
  fetch data from the table: "blacklist_refresh_token"
  """
  blacklist_refresh_token(
    """distinct select on columns"""
    distinct_on: [blacklist_refresh_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blacklist_refresh_token_order_by!]

    """filter the rows returned"""
    where: blacklist_refresh_token_bool_exp
  ): [blacklist_refresh_token!]!

  """
  fetch aggregated fields from the table: "blacklist_refresh_token"
  """
  blacklist_refresh_token_aggregate(
    """distinct select on columns"""
    distinct_on: [blacklist_refresh_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blacklist_refresh_token_order_by!]

    """filter the rows returned"""
    where: blacklist_refresh_token_bool_exp
  ): blacklist_refresh_token_aggregate!

  """
  fetch data from the table: "blacklist_refresh_token" using primary key columns
  """
  blacklist_refresh_token_by_pk(sig: String!): blacklist_refresh_token

  """
  fetch data from the table: "connectors"
  """
  connectors(
    """distinct select on columns"""
    distinct_on: [connectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_order_by!]

    """filter the rows returned"""
    where: connectors_bool_exp
  ): [connectors!]!

  """
  fetch aggregated fields from the table: "connectors"
  """
  connectors_aggregate(
    """distinct select on columns"""
    distinct_on: [connectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_order_by!]

    """filter the rows returned"""
    where: connectors_bool_exp
  ): connectors_aggregate!

  """fetch data from the table: "connectors" using primary key columns"""
  connectors_by_pk(name: String!): connectors

  """
  fetch data from the table: "customer_user"
  """
  customer_user(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): [customer_user!]!

  """
  fetch aggregated fields from the table: "customer_user"
  """
  customer_user_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): customer_user_aggregate!

  """fetch data from the table: "customer_user" using primary key columns"""
  customer_user_by_pk(customer_id: uuid!, user_id: uuid!): customer_user

  """
  fetch data from the table: "customer_user_service"
  """
  customer_user_service(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): [customer_user_service!]!

  """
  fetch aggregated fields from the table: "customer_user_service"
  """
  customer_user_service_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): customer_user_service_aggregate!

  """
  fetch data from the table: "customer_user_service" using primary key columns
  """
  customer_user_service_by_pk(customer_id: uuid!, service: services_enum!, user_id: uuid!): customer_user_service

  """
  fetch data from the table: "customer_user_sub_service"
  """
  customer_user_sub_service(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): [customer_user_sub_service!]!

  """
  fetch aggregated fields from the table: "customer_user_sub_service"
  """
  customer_user_sub_service_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): customer_user_sub_service_aggregate!

  """
  fetch data from the table: "customer_user_sub_service" using primary key columns
  """
  customer_user_sub_service_by_pk(customer_id: uuid!, service: services_enum!, sub_service: String!, user_id: uuid!): customer_user_sub_service

  """An array relationship"""
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """An aggregate relationship"""
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """fetch data from the table: "customers" using primary key columns"""
  customers_by_pk(id: uuid!): customers

  """
  fetch data from the table: "customers_contact"
  """
  customers_contact(
    """distinct select on columns"""
    distinct_on: [customers_contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_contact_order_by!]

    """filter the rows returned"""
    where: customers_contact_bool_exp
  ): [customers_contact!]!

  """
  fetch aggregated fields from the table: "customers_contact"
  """
  customers_contact_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_contact_order_by!]

    """filter the rows returned"""
    where: customers_contact_bool_exp
  ): customers_contact_aggregate!

  """
  fetch data from the table: "customers_contact" using primary key columns
  """
  customers_contact_by_pk(customer_id: uuid!): customers_contact

  """
  fetch data from the table: "feature_names"
  """
  feature_names(
    """distinct select on columns"""
    distinct_on: [feature_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_names_order_by!]

    """filter the rows returned"""
    where: feature_names_bool_exp
  ): [feature_names!]!

  """
  fetch aggregated fields from the table: "feature_names"
  """
  feature_names_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_names_order_by!]

    """filter the rows returned"""
    where: feature_names_bool_exp
  ): feature_names_aggregate!

  """fetch data from the table: "feature_names" using primary key columns"""
  feature_names_by_pk(name: String!): feature_names

  """An array relationship"""
  features(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): [features!]!

  """An aggregate relationship"""
  features_aggregate(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): features_aggregate!

  """fetch data from the table: "features" using primary key columns"""
  features_by_pk(customer_id: uuid!, name: feature_names_enum!): features
  getCustomerById(id: uuid!): getCustomersAndCountUsersOutput
  getCustomersAndCountUsers: [getCustomersAndCountUsersOutput]

  """
  fetch data from the table: "partners"
  """
  partners(
    """distinct select on columns"""
    distinct_on: [partners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partners_order_by!]

    """filter the rows returned"""
    where: partners_bool_exp
  ): [partners!]!

  """
  fetch aggregated fields from the table: "partners"
  """
  partners_aggregate(
    """distinct select on columns"""
    distinct_on: [partners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partners_order_by!]

    """filter the rows returned"""
    where: partners_bool_exp
  ): partners_aggregate!

  """fetch data from the table: "partners" using primary key columns"""
  partners_by_pk(id: uuid!): partners

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(name: String!): roles

  """
  fetch data from the table: "services"
  """
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """
  fetch aggregated fields from the table: "services"
  """
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(name: String!): services

  """
  fetch data from the table: "srv_names"
  """
  srv_names(
    """distinct select on columns"""
    distinct_on: [srv_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_names_order_by!]

    """filter the rows returned"""
    where: srv_names_bool_exp
  ): [srv_names!]!

  """
  fetch aggregated fields from the table: "srv_names"
  """
  srv_names_aggregate(
    """distinct select on columns"""
    distinct_on: [srv_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_names_order_by!]

    """filter the rows returned"""
    where: srv_names_bool_exp
  ): srv_names_aggregate!

  """fetch data from the table: "srv_names" using primary key columns"""
  srv_names_by_pk(name: String!): srv_names

  """An array relationship"""
  srv_urls(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): [srv_urls!]!

  """An aggregate relationship"""
  srv_urls_aggregate(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): srv_urls_aggregate!

  """fetch data from the table: "srv_urls" using primary key columns"""
  srv_urls_by_pk(customer_id: uuid!, name: srv_names_enum!): srv_urls

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(name: String!): status

  """
  fetch data from the table: "sub_services"
  """
  sub_services(
    """distinct select on columns"""
    distinct_on: [sub_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sub_services_order_by!]

    """filter the rows returned"""
    where: sub_services_bool_exp
  ): [sub_services!]!

  """An aggregate relationship"""
  sub_services_aggregate(
    """distinct select on columns"""
    distinct_on: [sub_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sub_services_order_by!]

    """filter the rows returned"""
    where: sub_services_bool_exp
  ): sub_services_aggregate!

  """fetch data from the table: "sub_services" using primary key columns"""
  sub_services_by_pk(name: String!, service: services_enum!): sub_services

  """An array relationship"""
  user_basic_data(
    """distinct select on columns"""
    distinct_on: [user_basic_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_basic_data_order_by!]

    """filter the rows returned"""
    where: user_basic_data_bool_exp
  ): [user_basic_data!]!

  """An aggregate relationship"""
  user_basic_data_aggregate(
    """distinct select on columns"""
    distinct_on: [user_basic_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_basic_data_order_by!]

    """filter the rows returned"""
    where: user_basic_data_bool_exp
  ): user_basic_data_aggregate!

  """fetch data from the table: "user_basic_data" using primary key columns"""
  user_basic_data_by_pk(user_id: uuid!): user_basic_data

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """An array relationship"""
  users_auth_logs(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): [users_auth_logs!]!

  """An aggregate relationship"""
  users_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): users_auth_logs_aggregate!

  """fetch data from the table: "users_auth_logs" using primary key columns"""
  users_auth_logs_by_pk(id: Int!): users_auth_logs

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
}

"""
columns and relationships of "roles"
"""
type roles {
  comment: String
  name: String!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  comment: String_comparison_exp
  name: String_comparison_exp
  users: users_bool_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """unique or primary key constraint"""
  roles_pkey
}

enum roles_enum {
  ADMIN

  """recipient role for advoca"""
  RECIPIENT

  """is super user within org"""
  SUPER_USER
  THERAPIST

  """basic role of all users"""
  USER
}

"""
Boolean expression to compare columns of type "roles_enum". All fields are combined with logical 'AND'.
"""
input roles_enum_comparison_exp {
  _eq: roles_enum
  _in: [roles_enum!]
  _is_null: Boolean
  _neq: roles_enum
  _nin: [roles_enum!]
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  comment: String
  name: String
  users: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type roles_max_fields {
  comment: String
  name: String
}

"""aggregate min on columns"""
type roles_min_fields {
  comment: String
  name: String
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!

  """on conflict condition"""
  on_conflict: roles_on_conflict
}

"""
on conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""Ordering options when selecting data from "roles"."""
input roles_order_by {
  comment: order_by
  name: order_by
  users_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: roles"""
input roles_pk_columns_input {
  name: String!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  comment: String
  name: String
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
columns and relationships of "services"
"""
type services {
  comment: String

  """An array relationship"""
  customer_user_services(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): [customer_user_service!]!

  """An aggregate relationship"""
  customer_user_services_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): customer_user_service_aggregate!

  """An array relationship"""
  customer_user_sub_services(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): [customer_user_sub_service!]!

  """An aggregate relationship"""
  customer_user_sub_services_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): customer_user_sub_service_aggregate!
  name: String!

  """
  fetch data from the table: "sub_services"
  """
  sub_services(
    """distinct select on columns"""
    distinct_on: [sub_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sub_services_order_by!]

    """filter the rows returned"""
    where: sub_services_bool_exp
  ): [sub_services!]!

  """An aggregate relationship"""
  sub_services_aggregate(
    """distinct select on columns"""
    distinct_on: [sub_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sub_services_order_by!]

    """filter the rows returned"""
    where: sub_services_bool_exp
  ): sub_services_aggregate!
}

"""
aggregated selection of "services"
"""
type services_aggregate {
  aggregate: services_aggregate_fields
  nodes: [services!]!
}

"""
aggregate fields of "services"
"""
type services_aggregate_fields {
  count(columns: [services_select_column!], distinct: Boolean): Int!
  max: services_max_fields
  min: services_min_fields
}

"""
Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'.
"""
input services_bool_exp {
  _and: [services_bool_exp!]
  _not: services_bool_exp
  _or: [services_bool_exp!]
  comment: String_comparison_exp
  customer_user_services: customer_user_service_bool_exp
  customer_user_sub_services: customer_user_sub_service_bool_exp
  name: String_comparison_exp
  sub_services: sub_services_bool_exp
}

"""
unique or primary key constraints on table "services"
"""
enum services_constraint {
  """unique or primary key constraint"""
  accessible_services_name_key

  """unique or primary key constraint"""
  accessible_services_pkey
}

enum services_enum {
  """Designer"""
  designer

  """Microsoft Office"""
  microsoft_office
}

"""
Boolean expression to compare columns of type "services_enum". All fields are combined with logical 'AND'.
"""
input services_enum_comparison_exp {
  _eq: services_enum
  _in: [services_enum!]
  _is_null: Boolean
  _neq: services_enum
  _nin: [services_enum!]
}

"""
input type for inserting data into table "services"
"""
input services_insert_input {
  comment: String
  customer_user_services: customer_user_service_arr_rel_insert_input
  customer_user_sub_services: customer_user_sub_service_arr_rel_insert_input
  name: String
  sub_services: sub_services_arr_rel_insert_input
}

"""aggregate max on columns"""
type services_max_fields {
  comment: String
  name: String
}

"""aggregate min on columns"""
type services_min_fields {
  comment: String
  name: String
}

"""
response of any mutation on the table "services"
"""
type services_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [services!]!
}

"""
input type for inserting object relation for remote table "services"
"""
input services_obj_rel_insert_input {
  data: services_insert_input!

  """on conflict condition"""
  on_conflict: services_on_conflict
}

"""
on conflict condition type for table "services"
"""
input services_on_conflict {
  constraint: services_constraint!
  update_columns: [services_update_column!]! = []
  where: services_bool_exp
}

"""Ordering options when selecting data from "services"."""
input services_order_by {
  comment: order_by
  customer_user_services_aggregate: customer_user_service_aggregate_order_by
  customer_user_sub_services_aggregate: customer_user_sub_service_aggregate_order_by
  name: order_by
  sub_services_aggregate: sub_services_aggregate_order_by
}

"""primary key columns input for table: services"""
input services_pk_columns_input {
  name: String!
}

"""
select columns of table "services"
"""
enum services_select_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
input type for updating data in table "services"
"""
input services_set_input {
  comment: String
  name: String
}

"""
update columns of table "services"
"""
enum services_update_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
columns and relationships of "srv_names"
"""
type srv_names {
  description: String!
  name: String!

  """An array relationship"""
  srv_urls(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): [srv_urls!]!

  """An aggregate relationship"""
  srv_urls_aggregate(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): srv_urls_aggregate!
}

"""
aggregated selection of "srv_names"
"""
type srv_names_aggregate {
  aggregate: srv_names_aggregate_fields
  nodes: [srv_names!]!
}

"""
aggregate fields of "srv_names"
"""
type srv_names_aggregate_fields {
  count(columns: [srv_names_select_column!], distinct: Boolean): Int!
  max: srv_names_max_fields
  min: srv_names_min_fields
}

"""
Boolean expression to filter rows from the table "srv_names". All fields are combined with a logical 'AND'.
"""
input srv_names_bool_exp {
  _and: [srv_names_bool_exp!]
  _not: srv_names_bool_exp
  _or: [srv_names_bool_exp!]
  description: String_comparison_exp
  name: String_comparison_exp
  srv_urls: srv_urls_bool_exp
}

"""
unique or primary key constraints on table "srv_names"
"""
enum srv_names_constraint {
  """unique or primary key constraint"""
  srv_names_pkey
}

enum srv_names_enum {
  """info about connector"""
  connector
}

"""
Boolean expression to compare columns of type "srv_names_enum". All fields are combined with logical 'AND'.
"""
input srv_names_enum_comparison_exp {
  _eq: srv_names_enum
  _in: [srv_names_enum!]
  _is_null: Boolean
  _neq: srv_names_enum
  _nin: [srv_names_enum!]
}

"""
input type for inserting data into table "srv_names"
"""
input srv_names_insert_input {
  description: String
  name: String
  srv_urls: srv_urls_arr_rel_insert_input
}

"""aggregate max on columns"""
type srv_names_max_fields {
  description: String
  name: String
}

"""aggregate min on columns"""
type srv_names_min_fields {
  description: String
  name: String
}

"""
response of any mutation on the table "srv_names"
"""
type srv_names_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [srv_names!]!
}

"""
input type for inserting object relation for remote table "srv_names"
"""
input srv_names_obj_rel_insert_input {
  data: srv_names_insert_input!

  """on conflict condition"""
  on_conflict: srv_names_on_conflict
}

"""
on conflict condition type for table "srv_names"
"""
input srv_names_on_conflict {
  constraint: srv_names_constraint!
  update_columns: [srv_names_update_column!]! = []
  where: srv_names_bool_exp
}

"""Ordering options when selecting data from "srv_names"."""
input srv_names_order_by {
  description: order_by
  name: order_by
  srv_urls_aggregate: srv_urls_aggregate_order_by
}

"""primary key columns input for table: srv_names"""
input srv_names_pk_columns_input {
  name: String!
}

"""
select columns of table "srv_names"
"""
enum srv_names_select_column {
  """column name"""
  description

  """column name"""
  name
}

"""
input type for updating data in table "srv_names"
"""
input srv_names_set_input {
  description: String
  name: String
}

"""
update columns of table "srv_names"
"""
enum srv_names_update_column {
  """column name"""
  description

  """column name"""
  name
}

"""
columns and relationships of "srv_urls"
"""
type srv_urls {
  """An object relationship"""
  customer: customers!
  customer_id: uuid!
  name: srv_names_enum!

  """An object relationship"""
  srv_name: srv_names!
  url: String!
}

"""
aggregated selection of "srv_urls"
"""
type srv_urls_aggregate {
  aggregate: srv_urls_aggregate_fields
  nodes: [srv_urls!]!
}

"""
aggregate fields of "srv_urls"
"""
type srv_urls_aggregate_fields {
  count(columns: [srv_urls_select_column!], distinct: Boolean): Int!
  max: srv_urls_max_fields
  min: srv_urls_min_fields
}

"""
order by aggregate values of table "srv_urls"
"""
input srv_urls_aggregate_order_by {
  count: order_by
  max: srv_urls_max_order_by
  min: srv_urls_min_order_by
}

"""
input type for inserting array relation for remote table "srv_urls"
"""
input srv_urls_arr_rel_insert_input {
  data: [srv_urls_insert_input!]!

  """on conflict condition"""
  on_conflict: srv_urls_on_conflict
}

"""
Boolean expression to filter rows from the table "srv_urls". All fields are combined with a logical 'AND'.
"""
input srv_urls_bool_exp {
  _and: [srv_urls_bool_exp!]
  _not: srv_urls_bool_exp
  _or: [srv_urls_bool_exp!]
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  name: srv_names_enum_comparison_exp
  srv_name: srv_names_bool_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "srv_urls"
"""
enum srv_urls_constraint {
  """unique or primary key constraint"""
  srv_urls_pkey
}

"""
input type for inserting data into table "srv_urls"
"""
input srv_urls_insert_input {
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  name: srv_names_enum
  srv_name: srv_names_obj_rel_insert_input
  url: String
}

"""aggregate max on columns"""
type srv_urls_max_fields {
  customer_id: uuid
  url: String
}

"""
order by max() on columns of table "srv_urls"
"""
input srv_urls_max_order_by {
  customer_id: order_by
  url: order_by
}

"""aggregate min on columns"""
type srv_urls_min_fields {
  customer_id: uuid
  url: String
}

"""
order by min() on columns of table "srv_urls"
"""
input srv_urls_min_order_by {
  customer_id: order_by
  url: order_by
}

"""
response of any mutation on the table "srv_urls"
"""
type srv_urls_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [srv_urls!]!
}

"""
on conflict condition type for table "srv_urls"
"""
input srv_urls_on_conflict {
  constraint: srv_urls_constraint!
  update_columns: [srv_urls_update_column!]! = []
  where: srv_urls_bool_exp
}

"""Ordering options when selecting data from "srv_urls"."""
input srv_urls_order_by {
  customer: customers_order_by
  customer_id: order_by
  name: order_by
  srv_name: srv_names_order_by
  url: order_by
}

"""primary key columns input for table: srv_urls"""
input srv_urls_pk_columns_input {
  customer_id: uuid!
  name: srv_names_enum!
}

"""
select columns of table "srv_urls"
"""
enum srv_urls_select_column {
  """column name"""
  customer_id

  """column name"""
  name

  """column name"""
  url
}

"""
input type for updating data in table "srv_urls"
"""
input srv_urls_set_input {
  customer_id: uuid
  name: srv_names_enum
  url: String
}

"""
update columns of table "srv_urls"
"""
enum srv_urls_update_column {
  """column name"""
  customer_id

  """column name"""
  name

  """column name"""
  url
}

"""
columns and relationships of "status"
"""
type status {
  comment: String

  """An array relationship"""
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """An aggregate relationship"""
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!
  name: String!

  """An array relationship"""
  user_basic_data(
    """distinct select on columns"""
    distinct_on: [user_basic_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_basic_data_order_by!]

    """filter the rows returned"""
    where: user_basic_data_bool_exp
  ): [user_basic_data!]!

  """An aggregate relationship"""
  user_basic_data_aggregate(
    """distinct select on columns"""
    distinct_on: [user_basic_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_basic_data_order_by!]

    """filter the rows returned"""
    where: user_basic_data_bool_exp
  ): user_basic_data_aggregate!
}

"""
aggregated selection of "status"
"""
type status_aggregate {
  aggregate: status_aggregate_fields
  nodes: [status!]!
}

"""
aggregate fields of "status"
"""
type status_aggregate_fields {
  count(columns: [status_select_column!], distinct: Boolean): Int!
  max: status_max_fields
  min: status_min_fields
}

"""
Boolean expression to filter rows from the table "status". All fields are combined with a logical 'AND'.
"""
input status_bool_exp {
  _and: [status_bool_exp!]
  _not: status_bool_exp
  _or: [status_bool_exp!]
  comment: String_comparison_exp
  customers: customers_bool_exp
  name: String_comparison_exp
  user_basic_data: user_basic_data_bool_exp
}

"""
unique or primary key constraints on table "status"
"""
enum status_constraint {
  """unique or primary key constraint"""
  status_name_key

  """unique or primary key constraint"""
  status_pkey
}

enum status_enum {
  """some test data"""
  ACTIVE

  """user is not active"""
  INACTIVE
}

"""
Boolean expression to compare columns of type "status_enum". All fields are combined with logical 'AND'.
"""
input status_enum_comparison_exp {
  _eq: status_enum
  _in: [status_enum!]
  _is_null: Boolean
  _neq: status_enum
  _nin: [status_enum!]
}

"""
input type for inserting data into table "status"
"""
input status_insert_input {
  comment: String
  customers: customers_arr_rel_insert_input
  name: String
  user_basic_data: user_basic_data_arr_rel_insert_input
}

"""aggregate max on columns"""
type status_max_fields {
  comment: String
  name: String
}

"""aggregate min on columns"""
type status_min_fields {
  comment: String
  name: String
}

"""
response of any mutation on the table "status"
"""
type status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [status!]!
}

"""
input type for inserting object relation for remote table "status"
"""
input status_obj_rel_insert_input {
  data: status_insert_input!

  """on conflict condition"""
  on_conflict: status_on_conflict
}

"""
on conflict condition type for table "status"
"""
input status_on_conflict {
  constraint: status_constraint!
  update_columns: [status_update_column!]! = []
  where: status_bool_exp
}

"""Ordering options when selecting data from "status"."""
input status_order_by {
  comment: order_by
  customers_aggregate: customers_aggregate_order_by
  name: order_by
  user_basic_data_aggregate: user_basic_data_aggregate_order_by
}

"""primary key columns input for table: status"""
input status_pk_columns_input {
  name: String!
}

"""
select columns of table "status"
"""
enum status_select_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
input type for updating data in table "status"
"""
input status_set_input {
  comment: String
  name: String
}

"""
update columns of table "status"
"""
enum status_update_column {
  """column name"""
  comment

  """column name"""
  name
}

"""
columns and relationships of "sub_services"
"""
type sub_services {
  comment: String

  """An array relationship"""
  customer_user_sub_services(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): [customer_user_sub_service!]!

  """An aggregate relationship"""
  customer_user_sub_services_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): customer_user_sub_service_aggregate!
  name: String!
  service: services_enum!

  """An object relationship"""
  serviceByService: services!
}

"""
aggregated selection of "sub_services"
"""
type sub_services_aggregate {
  aggregate: sub_services_aggregate_fields
  nodes: [sub_services!]!
}

"""
aggregate fields of "sub_services"
"""
type sub_services_aggregate_fields {
  count(columns: [sub_services_select_column!], distinct: Boolean): Int!
  max: sub_services_max_fields
  min: sub_services_min_fields
}

"""
order by aggregate values of table "sub_services"
"""
input sub_services_aggregate_order_by {
  count: order_by
  max: sub_services_max_order_by
  min: sub_services_min_order_by
}

"""
input type for inserting array relation for remote table "sub_services"
"""
input sub_services_arr_rel_insert_input {
  data: [sub_services_insert_input!]!

  """on conflict condition"""
  on_conflict: sub_services_on_conflict
}

"""
Boolean expression to filter rows from the table "sub_services". All fields are combined with a logical 'AND'.
"""
input sub_services_bool_exp {
  _and: [sub_services_bool_exp!]
  _not: sub_services_bool_exp
  _or: [sub_services_bool_exp!]
  comment: String_comparison_exp
  customer_user_sub_services: customer_user_sub_service_bool_exp
  name: String_comparison_exp
  service: services_enum_comparison_exp
  serviceByService: services_bool_exp
}

"""
unique or primary key constraints on table "sub_services"
"""
enum sub_services_constraint {
  """unique or primary key constraint"""
  sub_services_pkey
}

"""
input type for inserting data into table "sub_services"
"""
input sub_services_insert_input {
  comment: String
  customer_user_sub_services: customer_user_sub_service_arr_rel_insert_input
  name: String
  service: services_enum
  serviceByService: services_obj_rel_insert_input
}

"""aggregate max on columns"""
type sub_services_max_fields {
  comment: String
  name: String
}

"""
order by max() on columns of table "sub_services"
"""
input sub_services_max_order_by {
  comment: order_by
  name: order_by
}

"""aggregate min on columns"""
type sub_services_min_fields {
  comment: String
  name: String
}

"""
order by min() on columns of table "sub_services"
"""
input sub_services_min_order_by {
  comment: order_by
  name: order_by
}

"""
response of any mutation on the table "sub_services"
"""
type sub_services_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sub_services!]!
}

"""
input type for inserting object relation for remote table "sub_services"
"""
input sub_services_obj_rel_insert_input {
  data: sub_services_insert_input!

  """on conflict condition"""
  on_conflict: sub_services_on_conflict
}

"""
on conflict condition type for table "sub_services"
"""
input sub_services_on_conflict {
  constraint: sub_services_constraint!
  update_columns: [sub_services_update_column!]! = []
  where: sub_services_bool_exp
}

"""Ordering options when selecting data from "sub_services"."""
input sub_services_order_by {
  comment: order_by
  customer_user_sub_services_aggregate: customer_user_sub_service_aggregate_order_by
  name: order_by
  service: order_by
  serviceByService: services_order_by
}

"""primary key columns input for table: sub_services"""
input sub_services_pk_columns_input {
  name: String!
  service: services_enum!
}

"""
select columns of table "sub_services"
"""
enum sub_services_select_column {
  """column name"""
  comment

  """column name"""
  name

  """column name"""
  service
}

"""
input type for updating data in table "sub_services"
"""
input sub_services_set_input {
  comment: String
  name: String
  service: services_enum
}

"""
update columns of table "sub_services"
"""
enum sub_services_update_column {
  """column name"""
  comment

  """column name"""
  name

  """column name"""
  service
}

type subscription_root {
  """
  fetch data from the table: "admins"
  """
  admins(
    """distinct select on columns"""
    distinct_on: [admins_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_order_by!]

    """filter the rows returned"""
    where: admins_bool_exp
  ): [admins!]!

  """
  fetch aggregated fields from the table: "admins"
  """
  admins_aggregate(
    """distinct select on columns"""
    distinct_on: [admins_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_order_by!]

    """filter the rows returned"""
    where: admins_bool_exp
  ): admins_aggregate!

  """
  fetch data from the table: "admins_auth_logs"
  """
  admins_auth_logs(
    """distinct select on columns"""
    distinct_on: [admins_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_auth_logs_order_by!]

    """filter the rows returned"""
    where: admins_auth_logs_bool_exp
  ): [admins_auth_logs!]!

  """An aggregate relationship"""
  admins_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [admins_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [admins_auth_logs_order_by!]

    """filter the rows returned"""
    where: admins_auth_logs_bool_exp
  ): admins_auth_logs_aggregate!

  """
  fetch data from the table: "admins_auth_logs" using primary key columns
  """
  admins_auth_logs_by_pk(id: Int!): admins_auth_logs

  """fetch data from the table: "admins" using primary key columns"""
  admins_by_pk(id: uuid!): admins

  """
  fetch data from the table: "auth_methods"
  """
  auth_methods(
    """distinct select on columns"""
    distinct_on: [auth_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_methods_order_by!]

    """filter the rows returned"""
    where: auth_methods_bool_exp
  ): [auth_methods!]!

  """
  fetch aggregated fields from the table: "auth_methods"
  """
  auth_methods_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_methods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_methods_order_by!]

    """filter the rows returned"""
    where: auth_methods_bool_exp
  ): auth_methods_aggregate!

  """fetch data from the table: "auth_methods" using primary key columns"""
  auth_methods_by_pk(name: String!): auth_methods

  """
  fetch data from the table: "blacklist_refresh_token"
  """
  blacklist_refresh_token(
    """distinct select on columns"""
    distinct_on: [blacklist_refresh_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blacklist_refresh_token_order_by!]

    """filter the rows returned"""
    where: blacklist_refresh_token_bool_exp
  ): [blacklist_refresh_token!]!

  """
  fetch aggregated fields from the table: "blacklist_refresh_token"
  """
  blacklist_refresh_token_aggregate(
    """distinct select on columns"""
    distinct_on: [blacklist_refresh_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [blacklist_refresh_token_order_by!]

    """filter the rows returned"""
    where: blacklist_refresh_token_bool_exp
  ): blacklist_refresh_token_aggregate!

  """
  fetch data from the table: "blacklist_refresh_token" using primary key columns
  """
  blacklist_refresh_token_by_pk(sig: String!): blacklist_refresh_token

  """
  fetch data from the table: "connectors"
  """
  connectors(
    """distinct select on columns"""
    distinct_on: [connectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_order_by!]

    """filter the rows returned"""
    where: connectors_bool_exp
  ): [connectors!]!

  """
  fetch aggregated fields from the table: "connectors"
  """
  connectors_aggregate(
    """distinct select on columns"""
    distinct_on: [connectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connectors_order_by!]

    """filter the rows returned"""
    where: connectors_bool_exp
  ): connectors_aggregate!

  """fetch data from the table: "connectors" using primary key columns"""
  connectors_by_pk(name: String!): connectors

  """
  fetch data from the table: "customer_user"
  """
  customer_user(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): [customer_user!]!

  """
  fetch aggregated fields from the table: "customer_user"
  """
  customer_user_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): customer_user_aggregate!

  """fetch data from the table: "customer_user" using primary key columns"""
  customer_user_by_pk(customer_id: uuid!, user_id: uuid!): customer_user

  """
  fetch data from the table: "customer_user_service"
  """
  customer_user_service(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): [customer_user_service!]!

  """
  fetch aggregated fields from the table: "customer_user_service"
  """
  customer_user_service_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): customer_user_service_aggregate!

  """
  fetch data from the table: "customer_user_service" using primary key columns
  """
  customer_user_service_by_pk(customer_id: uuid!, service: services_enum!, user_id: uuid!): customer_user_service

  """
  fetch data from the table: "customer_user_sub_service"
  """
  customer_user_sub_service(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): [customer_user_sub_service!]!

  """
  fetch aggregated fields from the table: "customer_user_sub_service"
  """
  customer_user_sub_service_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): customer_user_sub_service_aggregate!

  """
  fetch data from the table: "customer_user_sub_service" using primary key columns
  """
  customer_user_sub_service_by_pk(customer_id: uuid!, service: services_enum!, sub_service: String!, user_id: uuid!): customer_user_sub_service

  """An array relationship"""
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """An aggregate relationship"""
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """fetch data from the table: "customers" using primary key columns"""
  customers_by_pk(id: uuid!): customers

  """
  fetch data from the table: "customers_contact"
  """
  customers_contact(
    """distinct select on columns"""
    distinct_on: [customers_contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_contact_order_by!]

    """filter the rows returned"""
    where: customers_contact_bool_exp
  ): [customers_contact!]!

  """
  fetch aggregated fields from the table: "customers_contact"
  """
  customers_contact_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_contact_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_contact_order_by!]

    """filter the rows returned"""
    where: customers_contact_bool_exp
  ): customers_contact_aggregate!

  """
  fetch data from the table: "customers_contact" using primary key columns
  """
  customers_contact_by_pk(customer_id: uuid!): customers_contact

  """
  fetch data from the table: "feature_names"
  """
  feature_names(
    """distinct select on columns"""
    distinct_on: [feature_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_names_order_by!]

    """filter the rows returned"""
    where: feature_names_bool_exp
  ): [feature_names!]!

  """
  fetch aggregated fields from the table: "feature_names"
  """
  feature_names_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_names_order_by!]

    """filter the rows returned"""
    where: feature_names_bool_exp
  ): feature_names_aggregate!

  """fetch data from the table: "feature_names" using primary key columns"""
  feature_names_by_pk(name: String!): feature_names

  """An array relationship"""
  features(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): [features!]!

  """An aggregate relationship"""
  features_aggregate(
    """distinct select on columns"""
    distinct_on: [features_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [features_order_by!]

    """filter the rows returned"""
    where: features_bool_exp
  ): features_aggregate!

  """fetch data from the table: "features" using primary key columns"""
  features_by_pk(customer_id: uuid!, name: feature_names_enum!): features

  """
  fetch data from the table: "partners"
  """
  partners(
    """distinct select on columns"""
    distinct_on: [partners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partners_order_by!]

    """filter the rows returned"""
    where: partners_bool_exp
  ): [partners!]!

  """
  fetch aggregated fields from the table: "partners"
  """
  partners_aggregate(
    """distinct select on columns"""
    distinct_on: [partners_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [partners_order_by!]

    """filter the rows returned"""
    where: partners_bool_exp
  ): partners_aggregate!

  """fetch data from the table: "partners" using primary key columns"""
  partners_by_pk(id: uuid!): partners

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(name: String!): roles

  """
  fetch data from the table: "services"
  """
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """
  fetch aggregated fields from the table: "services"
  """
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(name: String!): services

  """
  fetch data from the table: "srv_names"
  """
  srv_names(
    """distinct select on columns"""
    distinct_on: [srv_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_names_order_by!]

    """filter the rows returned"""
    where: srv_names_bool_exp
  ): [srv_names!]!

  """
  fetch aggregated fields from the table: "srv_names"
  """
  srv_names_aggregate(
    """distinct select on columns"""
    distinct_on: [srv_names_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_names_order_by!]

    """filter the rows returned"""
    where: srv_names_bool_exp
  ): srv_names_aggregate!

  """fetch data from the table: "srv_names" using primary key columns"""
  srv_names_by_pk(name: String!): srv_names

  """An array relationship"""
  srv_urls(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): [srv_urls!]!

  """An aggregate relationship"""
  srv_urls_aggregate(
    """distinct select on columns"""
    distinct_on: [srv_urls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [srv_urls_order_by!]

    """filter the rows returned"""
    where: srv_urls_bool_exp
  ): srv_urls_aggregate!

  """fetch data from the table: "srv_urls" using primary key columns"""
  srv_urls_by_pk(customer_id: uuid!, name: srv_names_enum!): srv_urls

  """
  fetch data from the table: "status"
  """
  status(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): [status!]!

  """
  fetch aggregated fields from the table: "status"
  """
  status_aggregate(
    """distinct select on columns"""
    distinct_on: [status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [status_order_by!]

    """filter the rows returned"""
    where: status_bool_exp
  ): status_aggregate!

  """fetch data from the table: "status" using primary key columns"""
  status_by_pk(name: String!): status

  """
  fetch data from the table: "sub_services"
  """
  sub_services(
    """distinct select on columns"""
    distinct_on: [sub_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sub_services_order_by!]

    """filter the rows returned"""
    where: sub_services_bool_exp
  ): [sub_services!]!

  """An aggregate relationship"""
  sub_services_aggregate(
    """distinct select on columns"""
    distinct_on: [sub_services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sub_services_order_by!]

    """filter the rows returned"""
    where: sub_services_bool_exp
  ): sub_services_aggregate!

  """fetch data from the table: "sub_services" using primary key columns"""
  sub_services_by_pk(name: String!, service: services_enum!): sub_services

  """An array relationship"""
  user_basic_data(
    """distinct select on columns"""
    distinct_on: [user_basic_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_basic_data_order_by!]

    """filter the rows returned"""
    where: user_basic_data_bool_exp
  ): [user_basic_data!]!

  """An aggregate relationship"""
  user_basic_data_aggregate(
    """distinct select on columns"""
    distinct_on: [user_basic_data_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_basic_data_order_by!]

    """filter the rows returned"""
    where: user_basic_data_bool_exp
  ): user_basic_data_aggregate!

  """fetch data from the table: "user_basic_data" using primary key columns"""
  user_basic_data_by_pk(user_id: uuid!): user_basic_data

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """An array relationship"""
  users_auth_logs(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): [users_auth_logs!]!

  """An aggregate relationship"""
  users_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): users_auth_logs_aggregate!

  """fetch data from the table: "users_auth_logs" using primary key columns"""
  users_auth_logs_by_pk(id: Int!): users_auth_logs

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_basic_data"
"""
type user_basic_data {
  email: bpchar!
  name: bpchar!
  password: bpchar!
  status: status_enum!

  """An object relationship"""
  statusByStatus: status!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "user_basic_data"
"""
type user_basic_data_aggregate {
  aggregate: user_basic_data_aggregate_fields
  nodes: [user_basic_data!]!
}

"""
aggregate fields of "user_basic_data"
"""
type user_basic_data_aggregate_fields {
  count(columns: [user_basic_data_select_column!], distinct: Boolean): Int!
  max: user_basic_data_max_fields
  min: user_basic_data_min_fields
}

"""
order by aggregate values of table "user_basic_data"
"""
input user_basic_data_aggregate_order_by {
  count: order_by
  max: user_basic_data_max_order_by
  min: user_basic_data_min_order_by
}

"""
input type for inserting array relation for remote table "user_basic_data"
"""
input user_basic_data_arr_rel_insert_input {
  data: [user_basic_data_insert_input!]!

  """on conflict condition"""
  on_conflict: user_basic_data_on_conflict
}

"""
Boolean expression to filter rows from the table "user_basic_data". All fields are combined with a logical 'AND'.
"""
input user_basic_data_bool_exp {
  _and: [user_basic_data_bool_exp!]
  _not: user_basic_data_bool_exp
  _or: [user_basic_data_bool_exp!]
  email: bpchar_comparison_exp
  name: bpchar_comparison_exp
  password: bpchar_comparison_exp
  status: status_enum_comparison_exp
  statusByStatus: status_bool_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_basic_data"
"""
enum user_basic_data_constraint {
  """unique or primary key constraint"""
  user_basic_data_pkey

  """unique or primary key constraint"""
  user_basic_data_user_id_key
}

"""
input type for inserting data into table "user_basic_data"
"""
input user_basic_data_insert_input {
  email: bpchar
  name: bpchar
  password: bpchar
  status: status_enum
  statusByStatus: status_obj_rel_insert_input
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_basic_data_max_fields {
  email: bpchar
  name: bpchar
  password: bpchar
  user_id: uuid
}

"""
order by max() on columns of table "user_basic_data"
"""
input user_basic_data_max_order_by {
  email: order_by
  name: order_by
  password: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_basic_data_min_fields {
  email: bpchar
  name: bpchar
  password: bpchar
  user_id: uuid
}

"""
order by min() on columns of table "user_basic_data"
"""
input user_basic_data_min_order_by {
  email: order_by
  name: order_by
  password: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_basic_data"
"""
type user_basic_data_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_basic_data!]!
}

"""
input type for inserting object relation for remote table "user_basic_data"
"""
input user_basic_data_obj_rel_insert_input {
  data: user_basic_data_insert_input!

  """on conflict condition"""
  on_conflict: user_basic_data_on_conflict
}

"""
on conflict condition type for table "user_basic_data"
"""
input user_basic_data_on_conflict {
  constraint: user_basic_data_constraint!
  update_columns: [user_basic_data_update_column!]! = []
  where: user_basic_data_bool_exp
}

"""Ordering options when selecting data from "user_basic_data"."""
input user_basic_data_order_by {
  email: order_by
  name: order_by
  password: order_by
  status: order_by
  statusByStatus: status_order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_basic_data"""
input user_basic_data_pk_columns_input {
  user_id: uuid!
}

"""
select columns of table "user_basic_data"
"""
enum user_basic_data_select_column {
  """column name"""
  email

  """column name"""
  name

  """column name"""
  password

  """column name"""
  status

  """column name"""
  user_id
}

"""
input type for updating data in table "user_basic_data"
"""
input user_basic_data_set_input {
  email: bpchar
  name: bpchar
  password: bpchar
  status: status_enum
  user_id: uuid
}

"""
update columns of table "user_basic_data"
"""
enum user_basic_data_update_column {
  """column name"""
  email

  """column name"""
  name

  """column name"""
  password

  """column name"""
  status

  """column name"""
  user_id
}

"""
columns and relationships of "users"
"""
type users {
  created_at: timestamptz

  """An array relationship"""
  customer_user_services(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): [customer_user_service!]!

  """An aggregate relationship"""
  customer_user_services_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_service_order_by!]

    """filter the rows returned"""
    where: customer_user_service_bool_exp
  ): customer_user_service_aggregate!

  """An array relationship"""
  customer_user_sub_services(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): [customer_user_sub_service!]!

  """An aggregate relationship"""
  customer_user_sub_services_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_sub_service_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_sub_service_order_by!]

    """filter the rows returned"""
    where: customer_user_sub_service_bool_exp
  ): customer_user_sub_service_aggregate!

  """An array relationship"""
  customer_users(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): [customer_user!]!

  """An aggregate relationship"""
  customer_users_aggregate(
    """distinct select on columns"""
    distinct_on: [customer_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customer_user_order_by!]

    """filter the rows returned"""
    where: customer_user_bool_exp
  ): customer_user_aggregate!
  id: uuid!
  phone: String
  role: roles_enum!

  """An object relationship"""
  roleByRole: roles!
  token: bpchar
  updated_at: timestamptz

  """An object relationship"""
  user_basic_data: user_basic_data

  """An object relationship"""
  user_refresh_tokens: blacklist_refresh_token

  """An array relationship"""
  users_auth_logs(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): [users_auth_logs!]!

  """An aggregate relationship"""
  users_auth_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [users_auth_logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_auth_logs_order_by!]

    """filter the rows returned"""
    where: users_auth_logs_bool_exp
  ): users_auth_logs_aggregate!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """on conflict condition"""
  on_conflict: users_on_conflict
}

"""
columns and relationships of "users_auth_logs"
"""
type users_auth_logs {
  """An object relationship"""
  authMethodByAuthMethod: auth_methods!
  auth_method: auth_methods_enum!
  authenticated_at: timestamptz!

  """An object relationship"""
  customer: customers!
  customer_id: uuid!
  id: Int!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "users_auth_logs"
"""
type users_auth_logs_aggregate {
  aggregate: users_auth_logs_aggregate_fields
  nodes: [users_auth_logs!]!
}

"""
aggregate fields of "users_auth_logs"
"""
type users_auth_logs_aggregate_fields {
  avg: users_auth_logs_avg_fields
  count(columns: [users_auth_logs_select_column!], distinct: Boolean): Int!
  max: users_auth_logs_max_fields
  min: users_auth_logs_min_fields
  stddev: users_auth_logs_stddev_fields
  stddev_pop: users_auth_logs_stddev_pop_fields
  stddev_samp: users_auth_logs_stddev_samp_fields
  sum: users_auth_logs_sum_fields
  var_pop: users_auth_logs_var_pop_fields
  var_samp: users_auth_logs_var_samp_fields
  variance: users_auth_logs_variance_fields
}

"""
order by aggregate values of table "users_auth_logs"
"""
input users_auth_logs_aggregate_order_by {
  avg: users_auth_logs_avg_order_by
  count: order_by
  max: users_auth_logs_max_order_by
  min: users_auth_logs_min_order_by
  stddev: users_auth_logs_stddev_order_by
  stddev_pop: users_auth_logs_stddev_pop_order_by
  stddev_samp: users_auth_logs_stddev_samp_order_by
  sum: users_auth_logs_sum_order_by
  var_pop: users_auth_logs_var_pop_order_by
  var_samp: users_auth_logs_var_samp_order_by
  variance: users_auth_logs_variance_order_by
}

"""
input type for inserting array relation for remote table "users_auth_logs"
"""
input users_auth_logs_arr_rel_insert_input {
  data: [users_auth_logs_insert_input!]!

  """on conflict condition"""
  on_conflict: users_auth_logs_on_conflict
}

"""aggregate avg on columns"""
type users_auth_logs_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "users_auth_logs"
"""
input users_auth_logs_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "users_auth_logs". All fields are combined with a logical 'AND'.
"""
input users_auth_logs_bool_exp {
  _and: [users_auth_logs_bool_exp!]
  _not: users_auth_logs_bool_exp
  _or: [users_auth_logs_bool_exp!]
  authMethodByAuthMethod: auth_methods_bool_exp
  auth_method: auth_methods_enum_comparison_exp
  authenticated_at: timestamptz_comparison_exp
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  id: Int_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "users_auth_logs"
"""
enum users_auth_logs_constraint {
  """unique or primary key constraint"""
  login_logs_pkey
}

"""
input type for incrementing numeric columns in table "users_auth_logs"
"""
input users_auth_logs_inc_input {
  id: Int
}

"""
input type for inserting data into table "users_auth_logs"
"""
input users_auth_logs_insert_input {
  authMethodByAuthMethod: auth_methods_obj_rel_insert_input
  auth_method: auth_methods_enum
  authenticated_at: timestamptz
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  id: Int
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type users_auth_logs_max_fields {
  authenticated_at: timestamptz
  customer_id: uuid
  id: Int
  user_id: uuid
}

"""
order by max() on columns of table "users_auth_logs"
"""
input users_auth_logs_max_order_by {
  authenticated_at: order_by
  customer_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type users_auth_logs_min_fields {
  authenticated_at: timestamptz
  customer_id: uuid
  id: Int
  user_id: uuid
}

"""
order by min() on columns of table "users_auth_logs"
"""
input users_auth_logs_min_order_by {
  authenticated_at: order_by
  customer_id: order_by
  id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "users_auth_logs"
"""
type users_auth_logs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users_auth_logs!]!
}

"""
on conflict condition type for table "users_auth_logs"
"""
input users_auth_logs_on_conflict {
  constraint: users_auth_logs_constraint!
  update_columns: [users_auth_logs_update_column!]! = []
  where: users_auth_logs_bool_exp
}

"""Ordering options when selecting data from "users_auth_logs"."""
input users_auth_logs_order_by {
  authMethodByAuthMethod: auth_methods_order_by
  auth_method: order_by
  authenticated_at: order_by
  customer: customers_order_by
  customer_id: order_by
  id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: users_auth_logs"""
input users_auth_logs_pk_columns_input {
  id: Int!
}

"""
select columns of table "users_auth_logs"
"""
enum users_auth_logs_select_column {
  """column name"""
  auth_method

  """column name"""
  authenticated_at

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  user_id
}

"""
input type for updating data in table "users_auth_logs"
"""
input users_auth_logs_set_input {
  auth_method: auth_methods_enum
  authenticated_at: timestamptz
  customer_id: uuid
  id: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type users_auth_logs_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "users_auth_logs"
"""
input users_auth_logs_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type users_auth_logs_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "users_auth_logs"
"""
input users_auth_logs_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type users_auth_logs_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "users_auth_logs"
"""
input users_auth_logs_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type users_auth_logs_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "users_auth_logs"
"""
input users_auth_logs_sum_order_by {
  id: order_by
}

"""
update columns of table "users_auth_logs"
"""
enum users_auth_logs_update_column {
  """column name"""
  auth_method

  """column name"""
  authenticated_at

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type users_auth_logs_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "users_auth_logs"
"""
input users_auth_logs_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type users_auth_logs_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "users_auth_logs"
"""
input users_auth_logs_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type users_auth_logs_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "users_auth_logs"
"""
input users_auth_logs_variance_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  created_at: timestamptz_comparison_exp
  customer_user_services: customer_user_service_bool_exp
  customer_user_sub_services: customer_user_sub_service_bool_exp
  customer_users: customer_user_bool_exp
  id: uuid_comparison_exp
  phone: String_comparison_exp
  role: roles_enum_comparison_exp
  roleByRole: roles_bool_exp
  token: bpchar_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_basic_data: user_basic_data_bool_exp
  user_refresh_tokens: blacklist_refresh_token_bool_exp
  users_auth_logs: users_auth_logs_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  phone_role

  """unique or primary key constraint"""
  users_id_key

  """unique or primary key constraint"""
  users_pkey

  """unique or primary key constraint"""
  users_token_key
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  created_at: timestamptz
  customer_user_services: customer_user_service_arr_rel_insert_input
  customer_user_sub_services: customer_user_sub_service_arr_rel_insert_input
  customer_users: customer_user_arr_rel_insert_input
  id: uuid
  phone: String
  role: roles_enum
  roleByRole: roles_obj_rel_insert_input
  token: bpchar
  updated_at: timestamptz
  user_basic_data: user_basic_data_obj_rel_insert_input
  user_refresh_tokens: blacklist_refresh_token_obj_rel_insert_input
  users_auth_logs: users_auth_logs_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  created_at: timestamptz
  id: uuid
  phone: String
  token: bpchar
  updated_at: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  created_at: order_by
  id: order_by
  phone: order_by
  token: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  created_at: timestamptz
  id: uuid
  phone: String
  token: bpchar
  updated_at: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  created_at: order_by
  id: order_by
  phone: order_by
  token: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """on conflict condition"""
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  created_at: order_by
  customer_user_services_aggregate: customer_user_service_aggregate_order_by
  customer_user_sub_services_aggregate: customer_user_sub_service_aggregate_order_by
  customer_users_aggregate: customer_user_aggregate_order_by
  id: order_by
  phone: order_by
  role: order_by
  roleByRole: roles_order_by
  token: order_by
  updated_at: order_by
  user_basic_data: user_basic_data_order_by
  user_refresh_tokens: blacklist_refresh_token_order_by
  users_auth_logs_aggregate: users_auth_logs_aggregate_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  phone

  """column name"""
  role

  """column name"""
  token

  """column name"""
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  created_at: timestamptz
  id: uuid
  phone: String
  role: roles_enum
  token: bpchar
  updated_at: timestamptz
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  phone

  """column name"""
  role

  """column name"""
  token

  """column name"""
  updated_at
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
